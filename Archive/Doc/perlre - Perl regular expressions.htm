<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>perlre - Perl regular expressions</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
href="mailto:tchrist@perl.com" rev=made>
<META content="MSHTML 5.00.2614.3401" name=GENERATOR></HEAD>
<BODY><!-- INDEX BEGIN -->
<UL>
  <LI><A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#NAME">NAME</A> 
  <LI><A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#DESCRIPTION">DESCRIPTION</A> 

  <UL>
    <LI><A 
    href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#Regular_Expressions">Regular 
    Expressions</A> 
    <LI><A 
    href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#Backtracking">Backtracking</A> 

    <LI><A 
    href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#Version_8_Regular_Expressions">Version 
    8 Regular Expressions</A> 
    <LI><A 
    href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#WARNING_on_1_vs_1">WARNING 
    on \1 vs $1</A> 
    <LI><A 
    href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#Repeated_patterns_matching_zero_">Repeated 
    patterns matching zero-length substring</A> 
    <LI><A 
    href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#Creating_custom_RE_engines">Creating 
    custom RE engines</A> 
    <LI><A 
    href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#SEE_ALSO">SEE 
    ALSO</A> </LI></UL></LI></UL><!-- INDEX END -->
<HR>

<P>
<H1><A name=NAME>NAME</A></H1>
<P>perlre - Perl regular expressions 
<P>
<HR>

<H1><A name=DESCRIPTION>DESCRIPTION</A></H1>
<P>This page describes the syntax of regular expressions in Perl. For a 
description of how to <EM>use</EM> regular expressions in matching operations, 
plus various examples of the same, see discussion of <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#item_m">m//</A>, <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#item_s">s///</A>, <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#item_qr">qr//</A> and 
<CODE>??</CODE> in <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#Regexp_Quote_Like_Operators">Regexp 
Quote-Like Operators</A>. 
<P>The matching operations can have various modifiers. The modifiers that relate 
to the interpretation of the regular expression inside are listed below. For the 
modifiers that alter the way a regular expression is used by Perl, see <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#Regexp_Quote_Like_Operators">Regexp 
Quote-Like Operators</A> and <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#Gory_details_of_parsing_quoted_c">Gory 
details of parsing quoted constructs</A>. 
<DL compact>
  <DT><STRONG><A name=item_i>i</A></STRONG> 
  <DD>Do case-insensitive pattern matching. 
  <P>If <CODE>use locale</CODE> is in effect, the case map is taken from the 
  current locale. See <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perllocale.html">the perllocale 
  manpage</A>. 
  <P></P>
  <DT><STRONG><A name=item_m>m</A></STRONG> 
  <DD>Treat string as multiple lines. That is, change ``^'' and ``$'' from 
  matching at only the very start or end of the string to the start or end of 
  any line anywhere within the string, 
  <P></P>
  <DT><STRONG><A name=item_s>s</A></STRONG> 
  <DD>Treat string as single line. That is, change ``.'' to match any character 
  whatsoever, even a newline, which it normally would not match. 
  <P>The <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#item_s">/s</A> and 
  <A href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#item_m">/m</A> 
  modifiers both override the <CODE>$*</CODE> setting. That is, no matter what 
  <CODE>$*</CODE> contains, <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#item_s">/s</A> 
  without <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#item_m">/m</A> will 
  force ``^'' to match only at the beginning of the string and ``$'' to match 
  only at the end (or just before a newline at the end) of the string. Together, 
  as <CODE>/ms</CODE>, they let the ``.'' match any character whatsoever, while 
  yet allowing ``^'' and ``$'' to match, respectively, just after and just 
  before newlines within the string. 
  <P></P>
  <DT><STRONG><A name=item_x>x</A></STRONG> 
  <DD>Extend your pattern's legibility by permitting whitespace and comments. 
  </DD></DL>
<P>These are usually written as ``the <CODE>/x</CODE> modifier'', even though 
the delimiter in question might not actually be a slash. In fact, any of these 
modifiers may also be embedded within the regular expression itself using the 
new <CODE>(?...)</CODE> construct. See below. 
<P>The <CODE>/x</CODE> modifier itself needs a little more explanation. It tells 
the regular expression parser to ignore whitespace that is neither backslashed 
nor within a character class. You can use this to break up your regular 
expression into (slightly) more readable parts. The <CODE>#</CODE> character is 
also treated as a metacharacter introducing a comment, just as in ordinary Perl 
code. This also means that if you want real whitespace or <CODE>#</CODE> 
characters in the pattern (outside of a character class, where they are 
unaffected by <CODE>/x</CODE>), that you'll either have to escape them or encode 
them using octal or hex escapes. Taken together, these features go a long way 
towards making Perl's regular expressions more readable. Note that you have to 
be careful not to include the pattern delimiter in the comment--perl has no way 
of knowing you did not intend to close the pattern early. See the C-comment 
deletion code in <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html">the perlop 
manpage</A>. 
<P>
<HR>

<H2><A name=Regular_Expressions>Regular Expressions</A></H2>
<P>The patterns used in pattern matching are regular expressions such as those 
supplied in the Version 8 regex routines. (In fact, the routines are derived 
(distantly) from Henry Spencer's freely redistributable reimplementation of the 
<FONT size=-1>V8</FONT> routines.) See <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#Version_8_Regular_Expressions">Version 
8 Regular Expressions</A> for details. 
<P>In particular the following metacharacters have their standard 
<EM>egrep</EM>-ish meanings: 
<P><PRE>    \   Quote the next metacharacter
    ^   Match the beginning of the line
    .   Match any character (except newline)
    $   Match the end of the line (or before newline at the end)
    |   Alternation
    ()  Grouping
    []  Character class
</PRE>
<P>By default, the ``^'' character is guaranteed to match at only the beginning 
of the string, the ``$'' character at only the end (or before the newline at the 
end) and Perl does certain optimizations with the assumption that the string 
contains only one line. Embedded newlines will not be matched by ``^'' or ``$''. 
You may, however, wish to treat a string as a multi-line buffer, such that the 
``^'' will match after any newline within the string, and ``$'' will match 
before any newline. At the cost of a little more overhead, you can do this by 
using the <CODE>/m</CODE> modifier on the pattern match operator. (Older 
programs did this by setting <CODE>$*</CODE>, but this practice is now 
deprecated.) 
<P>To facilitate multi-line substitutions, the ``.'' character never matches a 
newline unless you use the <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#item_s">/s</A> 
modifier, which in effect tells Perl to pretend the string is a single 
line--even if it isn't. The <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#item_s">/s</A> 
modifier also overrides the setting of <CODE>$*</CODE>, in case you have some 
(badly behaved) older code that sets it in another module. 
<P>The following standard quantifiers are recognized: 
<P><PRE>    *      Match 0 or more times
    +      Match 1 or more times
    ?      Match 1 or 0 times
    {n}    Match exactly n times
    {n,}   Match at least n times
    {n,m}  Match at least n but not more than m times
</PRE>
<P>(If a curly bracket occurs in any other context, it is treated as a regular 
character.) The ``*'' modifier is equivalent to <CODE>{0,}</CODE>, the ``+'' 
modifier to <CODE>{1,}</CODE>, and the ``?'' modifier to <CODE>{0,1}</CODE>. n 
and m are limited to integral values less than 65536. 
<P>By default, a quantified subpattern is ``greedy'', that is, it will match as 
many times as possible (given a particular starting location) while still 
allowing the rest of the pattern to match. If you want it to match the minimum 
number of times possible, follow the quantifier with a ``?''. Note that the 
meanings don't change, just the ``greediness'': 
<P><PRE>    *?     Match 0 or more times
    +?     Match 1 or more times
    ??     Match 0 or 1 time
    {n}?   Match exactly n times
    {n,}?  Match at least n times
    {n,m}? Match at least n but not more than m times
</PRE>
<P>Because patterns are processed as double quoted strings, the following also 
work: 
<P><PRE>    \t          tab                   (HT, TAB)
    \n          newline               (LF, NL)
    \r          return                (CR)
    \f          form feed             (FF)
    \a          alarm (bell)          (BEL)
    \e          escape (think troff)  (ESC)
    \033        octal char (think of a PDP-11)
    \x1B        hex char
    \c[         control char
    \l          lowercase next char (think vi)
    \u          uppercase next char (think vi)
    \L          lowercase till \E (think vi)
    \U          uppercase till \E (think vi)
    \E          end case modification (think vi)
    \Q          quote (disable) pattern metacharacters till \E
</PRE>
<P>If <CODE>use locale</CODE> is in effect, the case map used by 
<CODE>\l</CODE>, <CODE>\L</CODE>, <CODE>\u</CODE> and <CODE>\U</CODE> is taken 
from the current locale. See <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perllocale.html">the perllocale 
manpage</A>. 
<P>You cannot include a literal <CODE>$</CODE> or <CODE>@</CODE> within a 
<CODE>\Q</CODE> sequence. An unescaped <CODE>$</CODE> or <CODE>@</CODE> 
interpolates the corresponding variable, while escaping will cause the literal 
string <CODE>\$</CODE> to be matched. You'll need to write something like 
<CODE>m/\Quser\E\@\Qhost/</CODE>. 
<P>In addition, Perl defines the following: 
<P><PRE>    \w  Match a "word" character (alphanumeric plus "_")
    \W  Match a non-word character
    \s  Match a whitespace character
    \S  Match a non-whitespace character
    \d  Match a digit character
    \D  Match a non-digit character
</PRE>
<P><FONT size=-1>A</FONT> <CODE>\w</CODE> matches a single alphanumeric 
character, not a whole word. To match a word you'd need to say <CODE>\w+</CODE>. 
If <CODE>use locale</CODE> is in effect, the list of alphabetic characters 
generated by <CODE>\w</CODE> is taken from the current locale. See <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perllocale.html">the perllocale 
manpage</A>. You may use <CODE>\w</CODE>, <CODE>\W</CODE>, <CODE>\s</CODE>, 
<CODE>\S</CODE>, <CODE>\d</CODE>, and <CODE>\D</CODE> within character classes 
(though not as either end of a range). 
<P>Perl defines the following zero-width assertions: 
<P><PRE>    \b  Match a word boundary
    \B  Match a non-(word boundary)
    \A  Match only at beginning of string
    \Z  Match only at end of string, or before newline at the end
    \z  Match only at end of string
    \G  Match only where previous m//g left off (works only with /g)
</PRE>
<P><FONT size=-1>A</FONT> word boundary (<CODE>\b</CODE>) is defined as a spot 
between two characters that has a <CODE>\w</CODE> on one side of it and a 
<CODE>\W</CODE> on the other side of it (in either order), counting the 
imaginary characters off the beginning and end of the string as matching a 
<CODE>\W</CODE>. (Within character classes <CODE>\b</CODE> represents backspace 
rather than a word boundary.) The <CODE>\A</CODE> and <CODE>\Z</CODE> are just 
like ``^'' and ``$'', except that they won't match multiple times when the <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#item__m">/m</A> 
modifier is used, while ``^'' and ``$'' will match at every internal line 
boundary. To match the actual end of the string, not ignoring newline, you can 
use <CODE>\z</CODE>. The <CODE>\G</CODE> assertion can be used to chain global 
matches (using <CODE>m//g</CODE>), as described in <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#Regexp_Quote_Like_Operators">Regexp 
Quote-Like Operators</A>. 
<P>It is also useful when writing <CODE>lex</CODE>-like scanners, when you have 
several patterns that you want to match against consequent substrings of your 
string, see the previous reference. The actual location where <CODE>\G</CODE> 
will match can also be influenced by using <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlfunc/pos.html">pos()</A> as 
an lvalue. See <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlfunc/pos.html">pos</A>. 
<P>When the bracketing construct <CODE>( ... )</CODE> is used, \&lt;digit&gt; 
matches the digit'th substring. Outside of the pattern, always use ``$'' instead 
of ``\'' in front of the digit. (While the \&lt;digit&gt; notation can on rare 
occasion work outside the current pattern, this should not be relied upon. See 
the <FONT size=-1>WARNING</FONT> below.) The scope of $&lt;digit&gt; (and 
<CODE>$`</CODE>, <CODE>$&amp;</CODE>, and <CODE>$'</CODE>) extends to the end of 
the enclosing <FONT size=-1>BLOCK</FONT> or eval string, or to the next 
successful pattern match, whichever comes first. If you want to use parentheses 
to delimit a subpattern (e.g., a set of alternatives) without saving it as a 
subpattern, follow the ( with a ?:. 
<P>You may have as many parentheses as you wish. If you have more than 9 
substrings, the variables $10, $11, ... refer to the corresponding substring. 
Within the pattern, \10, \11, etc. refer back to substrings if there have been 
at least that many left parentheses before the backreference. Otherwise (for 
backward compatibility) \10 is the same as \010, a backspace, and \11 the same 
as \011, a tab. And so on. (\1 through \9 are always backreferences.) 
<P><CODE>$+</CODE> returns whatever the last bracket match matched. 
<CODE>$&amp;</CODE> returns the entire matched string. (<CODE>$0</CODE> used to 
return the same thing, but not any more.) <CODE>$`</CODE> returns everything 
before the matched string. <CODE>$'</CODE> returns everything after the matched 
string. Examples: 
<P><PRE>    s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words
</PRE>
<P><PRE>    if (/Time: (..):(..):(..)/) {
        $hours = $1;
        $minutes = $2;
        $seconds = $3;
    }
</PRE>
<P>Once perl sees that you need one of <CODE>$&amp;</CODE>, <CODE>$`</CODE> or 
<CODE>$'</CODE> anywhere in the program, it has to provide them on each and 
every pattern match. This can slow your program down. The same mechanism that 
handles these provides for the use of $1, $2, etc., so you pay the same price 
for each pattern that contains capturing parentheses. But if you never use 
$&amp;, etc., in your script, then patterns <EM>without</EM> capturing 
parentheses won't be penalized. So avoid $&amp;, $', and $` if you can, but if 
you can't (and some algorithms really appreciate them), once you've used them 
once, use them at will, because you've already paid the price. As of 5.005, 
$&amp; is not so costly as the other two. 
<P>Backslashed metacharacters in Perl are alphanumeric, such as <CODE>\b</CODE>, 
<CODE>\w</CODE>, <CODE>\n</CODE>. Unlike some other regular expression 
languages, there are no backslashed symbols that aren't alphanumeric. So 
anything that looks like \\, \(, \), \&lt;, \&gt;, \{, or \} is always 
interpreted as a literal character, not a metacharacter. This was once used in a 
common idiom to disable or quote the special meanings of regular expression 
metacharacters in a string that you want to use for a pattern. Simply quote all 
non-alphanumeric characters: 
<P><PRE>    $pattern =~ s/(\W)/\\$1/g;
</PRE>
<P>Now it is much more common to see either the <CODE>quotemeta()</CODE> 
function or the <CODE>\Q</CODE> escape sequence used to disable all 
metacharacters' special meanings like this: 
<P><PRE>    /$unquoted\Q$quoted\E$unquoted/
</PRE>
<P>Perl defines a consistent extension syntax for regular expressions. The 
syntax is a pair of parentheses with a question mark as the first thing within 
the parentheses (this was a syntax error in older versions of Perl). The 
character after the question mark gives the function of the extension. Several 
extensions are already supported: 
<DL>
  <DT><STRONG><A name=item__text_>(?#text)</A></STRONG>
  <P></P>
  <DD><FONT size=-1>A</FONT> comment. The text is ignored. If the 
  <CODE>/x</CODE> switch is used to enable whitespace formatting, a simple 
  <CODE>#</CODE> will suffice. Note that perl closes the comment as soon as it 
  sees a <CODE>)</CODE>, so there is no way to put a literal <CODE>)</CODE> in 
  the comment. 
  <P></P>
  <DT><STRONG><A name=item__pattern_>(?:pattern)</A></STRONG>
  <DD>
  <DT><STRONG><A name=item__imsx_imsx_pattern_>(?imsx-imsx:pattern)</A></STRONG>
  <P></P>
  <DD>This is for clustering, not capturing; it groups subexpressions like 
  ``()'', but doesn't make backreferences as ``()'' does. So 
  <P><PRE>    @fields = split(/\b(?:a|b|c)\b/)
</PRE>
  <P>is like 
  <P><PRE>    @fields = split(/\b(a|b|c)\b/)
</PRE>
  <P>but doesn't spit out extra fields. 
  <P>The letters between <CODE>?</CODE> and <CODE>:</CODE> act as flags 
  modifiers, see <EM><CODE>(?imsx-imsx)</CODE></EM>. In particular, 
  <P><PRE>    /(?s-i:more.*than).*million/i
</PRE>
  <P>is equivalent to more verbose 
  <P><PRE>    /(?:(?s-i)more.*than).*million/i
</PRE>
  <DT><STRONG><A name=item__pattern_>(?=pattern)</A></STRONG>
  <P></P>
  <DD><FONT size=-1>A</FONT> zero-width positive lookahead assertion. For 
  example, <CODE>/\w+(?=\t)/</CODE> matches a word followed by a tab, without 
  including the tab in <CODE>$&amp;</CODE>. 
  <P></P>
  <DT><STRONG><A name=item__pattern_>(?!pattern)</A></STRONG>
  <P></P>
  <DD><FONT size=-1>A</FONT> zero-width negative lookahead assertion. For 
  example <CODE>/foo(?!bar)/</CODE> matches any occurrence of ``foo'' that isn't 
  followed by ``bar''. Note however that lookahead and lookbehind are <FONT 
  size=-1>NOT</FONT> the same thing. You cannot use this for lookbehind. 
  <P>If you are looking for a ``bar'' that isn't preceded by a ``foo'', 
  <CODE>/(?!foo)bar/</CODE> will not do what you want. That's because the 
  <CODE>(?!foo)</CODE> is just saying that the next thing cannot be ``foo''--and 
  it's not, it's a ``bar'', so ``foobar'' will match. You would have to do 
  something like <CODE>/(?!foo)...bar/</CODE> for that. We say ``like'' because 
  there's the case of your ``bar'' not having three characters before it. You 
  could cover that this way: <CODE>/(?:(?!foo)...|^.{0,2})bar/</CODE>. Sometimes 
  it's still easier just to say: 
  <P><PRE>    if (/bar/ &amp;&amp; $` !~ /foo$/)
</PRE>
  <P>For lookbehind see below. 
  <P></P>
  <DT><STRONG><A name=item__lt_pattern_>(?&lt;=pattern)</A></STRONG>
  <P></P>
  <DD><FONT size=-1>A</FONT> zero-width positive lookbehind assertion. For 
  example, <CODE>/(?&lt;=\t)\w+/</CODE> matches a word following a tab, without 
  including the tab in <CODE>$&amp;</CODE>. Works only for fixed-width 
  lookbehind. 
  <P></P>
  <DT><STRONG><A name=item_C>(?&lt;!pattern)</A></STRONG>
  <P></P>
  <DD><FONT size=-1>A</FONT> zero-width negative lookbehind assertion. For 
  example <CODE>/(?&lt;!bar)foo/</CODE> matches any occurrence of ``foo'' that 
  isn't following ``bar''. Works only for fixed-width lookbehind. 
  <P></P>
  <DT><STRONG>(?{ code })</STRONG>
  <P></P>
  <DD>Experimental ``evaluate any Perl code'' zero-width assertion. Always 
  succeeds. <CODE>code</CODE> is not interpolated. Currently the rules to 
  determine where the <CODE>code</CODE> ends are somewhat convoluted. 
  <P>The <CODE>code</CODE> is properly scoped in the following sense: if the 
  assertion is backtracked (compare <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#Backtracking">Backtracking</A>), 
  all the changes introduced after <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlfunc/local.html">local</A>isation 
  are undone, so 
  <P><PRE>  $_ = 'a' x 8;
  m&lt; 
     (?{ $cnt = 0 })                    # Initialize $cnt.
     (
       a 
       (?{
           local $cnt = $cnt + 1;       # Update $cnt, backtracking-safe.
       })
     )*  
     aaaa
     (?{ $res = $cnt })                 # On success copy to non-localized
                                        # location.
   &gt;x;
</PRE>
  <P>will set <CODE>$res = 4</CODE>. Note that after the match <CODE>$cnt</CODE> 
  returns to the globally introduced value 0, since the scopes which restrict <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlfunc/local.html">local</A> 
  statements are unwound. 
  <P>This assertion may be used as <EM>(?(condition)yes-pattern)</EM> switch. If 
  <EM>not</EM> used in this way, the result of evaluation of <CODE>code</CODE> 
  is put into variable <FONT size=-1>$^R.</FONT> This happens immediately, so 
  <FONT size=-1>$^R</FONT> can be used from other <CODE>(?{ code })</CODE> 
  assertions inside the same regular expression. 
  <P>The above assignment to <FONT size=-1>$^R</FONT> is properly localized, 
  thus the old value of <FONT size=-1>$^R</FONT> is restored if the assertion is 
  backtracked (compare <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#Backtracking">Backtracking</A>). 

  <P>Due to security concerns, this construction is not allowed if the regular 
  expression involves run-time interpolation of variables, unless <CODE>use re 
  'eval'</CODE> pragma is used (see <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/lib/re.html">the re manpage</A>), 
  or the variables contain results of <CODE>qr()</CODE> operator (see <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#item_qr">qr/STRING/imosx</A>). 

  <P>This restriction is due to the wide-spread (questionable) practice of using 
  the construct 
  <P><PRE>    $re = &lt;&gt;;
    chomp $re;
    $string =~ /$re/;
</PRE>
  <P>without tainting. While this code is frowned upon from security point of 
  view, when <CODE>(?{})</CODE> was introduced, it was considered bad to add 
  <EM>new</EM> security holes to existing scripts. 
  <P><STRONG>NOTE:</STRONG> Use of the above insecure snippet without also 
  enabling taint mode is to be severely frowned upon. <CODE>use re 'eval'</CODE> 
  does not disable tainting checks, thus to allow <CODE>$re</CODE> in the above 
  snippet to contain <CODE>(?{})</CODE> <EM>with tainting enabled</EM>, one 
  needs both <CODE>use re 'eval'</CODE> and untaint the $re. 
  <P></P>
  <DT><STRONG><A name=item__gtpattern_>(?&gt;pattern)</A></STRONG>
  <P></P>
  <DD>An ``independent'' subexpression. Matches the substring that a 
  <EM>standalone</EM> <CODE>pattern</CODE> would match if anchored at the given 
  position, <STRONG>and only this substring</STRONG>. 
  <P>Say, <CODE>^(?&gt;a*)ab</CODE> will never match, since 
  <CODE>(?&gt;a*)</CODE> (anchored at the beginning of string, as above) will 
  match <EM>all</EM> characters <CODE>a</CODE> at the beginning of string, 
  leaving no <CODE>a</CODE> for <CODE>ab</CODE> to match. In contrast, 
  <CODE>a*ab</CODE> will match the same as <CODE>a+b</CODE>, since the match of 
  the subgroup <CODE>a*</CODE> is influenced by the following group 
  <CODE>ab</CODE> (see <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#Backtracking">Backtracking</A>). 
  In particular, <CODE>a*</CODE> inside <CODE>a*ab</CODE> will match fewer 
  characters than a standalone <CODE>a*</CODE>, since this makes the tail match. 

  <P>An effect similar to <CODE>(?&gt;pattern)</CODE> may be achieved by 
  <P><PRE>   (?=(pattern))\1
</PRE>
  <P>since the lookahead is in <EM>"logical"</EM> context, thus matches the same 
  substring as a standalone <CODE>a+</CODE>. The following <CODE>\1</CODE> eats 
  the matched string, thus making a zero-length assertion into an analogue of 
  <CODE>(?&gt;...)</CODE>. (The difference between these two constructs is that 
  the second one uses a catching group, thus shifting ordinals of backreferences 
  in the rest of a regular expression.) 
  <P>This construct is useful for optimizations of ``eternal'' matches, because 
  it will not backtrack (see <A 
  href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#Backtracking">Backtracking</A>). 

  <P><PRE>    m{ \(
          ( 
            [^()]+ 
          | 
            \( [^()]* \)
          )+
       \) 
     }x
</PRE>
  <P>That will efficiently match a nonempty group with matching 
  two-or-less-level-deep parentheses. However, if there is no such group, it 
  will take virtually forever on a long string. That's because there are so many 
  different ways to split a long string into several substrings. This is what 
  <CODE>(.+)+</CODE> is doing, and <CODE>(.+)+</CODE> is similar to a subpattern 
  of the above pattern. Consider that the above pattern detects no-match on 
  <CODE>((()aaaaaaaaaaaaaaaaaa</CODE> in several seconds, but that each extra 
  letter doubles this time. This exponential performance will make it appear 
  that your program has hung. 
  <P>However, a tiny modification of this pattern 
  <P><PRE>    m{ \( 
          ( 
            (?&gt; [^()]+ )
          | 
            \( [^()]* \)
          )+
       \) 
     }x
</PRE>
  <P>which uses <CODE>(?&gt;...)</CODE> matches exactly when the one above does 
  (verifying this yourself would be a productive exercise), but finishes in a 
  fourth the time when used on a similar string with 1000000 <CODE>a</CODE>s. Be 
  aware, however, that this pattern currently triggers a warning message under 
  <STRONG>-w</STRONG> saying it <CODE>"matches the null string many 
  times"</CODE>): 
  <P>On simple groups, such as the pattern <CODE>(?</CODE> [^()]+ )&gt;, a 
  comparable effect may be achieved by negative lookahead, as in <CODE>[^()]+ 
  (?! [^()] )</CODE>. This was only 4 times slower on a string with 1000000 
  <CODE>a</CODE>s. 
  <P></P>
  <DT><STRONG><A 
  name=item__condition_yes_pattern_no_patt>(?(condition)yes-pattern|no-pattern)</A></STRONG>
  <DD>
  <DT><STRONG><A 
  name=item__condition_yes_pattern_>(?(condition)yes-pattern)</A></STRONG>
  <P></P>
  <DD>Conditional expression. <CODE>(condition)</CODE> should be either an 
  integer in parentheses (which is valid if the corresponding pair of 
  parentheses matched), or lookahead/lookbehind/evaluate zero-width assertion. 
  <P>Say, 
  <P><PRE>    m{ ( \( )? 
       [^()]+ 
       (?(1) \) ) 
     }x
</PRE>
  <P>matches a chunk of non-parentheses, possibly included in parentheses 
  themselves. 
  <P></P>
  <DT><STRONG><A name=item__imsx_imsx_>(?imsx-imsx)</A></STRONG>
  <P></P>
  <DD>One or more embedded pattern-match modifiers. This is particularly useful 
  for patterns that are specified in a table somewhere, some of which want to be 
  case sensitive, and some of which don't. The case insensitive ones need to 
  include merely <CODE>(?i)</CODE> at the front of the pattern. For example: 
  <P><PRE>    $pattern = "foobar";
    if ( /$pattern/i ) { } 
</PRE>
  <P><PRE>    # more flexible:
</PRE>
  <P><PRE>    $pattern = "(?i)foobar";
    if ( /$pattern/ ) { } 
</PRE>
  <P>Letters after <CODE>-</CODE> switch modifiers off. 
  <P>These modifiers are localized inside an enclosing group (if any). Say, 
  <P><PRE>    ( (?i) blah ) \s+ \1
</PRE>
  <P>(assuming <CODE>x</CODE> modifier, and no <CODE>i</CODE> modifier outside 
  of this group) will match a repeated (<EM>including the case</EM>!) word 
  <CODE>blah</CODE> in any case. </P></DD></DL>
<P><FONT size=-1>A</FONT> question mark was chosen for this and for the new 
minimal-matching construct because 1) question mark is pretty rare in older 
regular expressions, and 2) whenever you see one, you should stop and 
``question'' exactly what is going on. That's psychology... 
<P>
<HR>

<H2><A name=Backtracking>Backtracking</A></H2>
<P><FONT size=-1>A</FONT> fundamental feature of regular expression matching 
involves the notion called <EM>backtracking</EM>, which is currently used (when 
needed) by all regular expression quantifiers, namely <CODE>*</CODE>, 
<CODE>*?</CODE>, <CODE>+</CODE>, <CODE>+?</CODE>, <CODE>{n,m}</CODE>, and 
<CODE>{n,m}?</CODE>. 
<P>For a regular expression to match, the <EM>entire</EM> regular expression 
must match, not just part of it. So if the beginning of a pattern containing a 
quantifier succeeds in a way that causes later parts in the pattern to fail, the 
matching engine backs up and recalculates the beginning part--that's why it's 
called backtracking. 
<P>Here is an example of backtracking: Let's say you want to find the word 
following ``foo'' in the string ``Food is on the foo table.'': 
<P><PRE>    $_ = "Food is on the foo table.";
    if ( /\b(foo)\s+(\w+)/i ) {
        print "$2 follows $1.\n";
    }
</PRE>
<P>When the match runs, the first part of the regular expression 
(<CODE>\b(foo)</CODE>) finds a possible match right at the beginning of the 
string, and loads up <CODE>$1</CODE> with ``Foo''. However, as soon as the 
matching engine sees that there's no whitespace following the ``Foo'' that it 
had saved in $1, it realizes its mistake and starts over again one character 
after where it had the tentative match. This time it goes all the way until the 
next occurrence of ``foo''. The complete regular expression matches this time, 
and you get the expected output of ``table follows foo.'' 
<P>Sometimes minimal matching can help a lot. Imagine you'd like to match 
everything between ``foo'' and ``bar''. Initially, you write something like 
this: 
<P><PRE>    $_ =  "The food is under the bar in the barn.";
    if ( /foo(.*)bar/ ) {
        print "got &lt;$1&gt;\n";
    }
</PRE>
<P>Which perhaps unexpectedly yields: 
<P><PRE>  got &lt;d is under the bar in the &gt;
</PRE>
<P>That's because <CODE>.*</CODE> was greedy, so you get everything between the 
<EM>first</EM> ``foo'' and the <EM>last</EM> ``bar''. In this case, it's more 
effective to use minimal matching to make sure you get the text between a 
``foo'' and the first ``bar'' thereafter. 
<P><PRE>    if ( /foo(.*?)bar/ ) { print "got &lt;$1&gt;\n" }
  got &lt;d is under the &gt;
</PRE>
<P>Here's another example: let's say you'd like to match a number at the end of 
a string, and you also want to keep the preceding part the match. So you write 
this: 
<P><PRE>    $_ = "I have 2 numbers: 53147";
    if ( /(.*)(\d*)/ ) {                                # Wrong!
        print "Beginning is &lt;$1&gt;, number is &lt;$2&gt;.\n";
    }
</PRE>
<P>That won't work at all, because <CODE>.*</CODE> was greedy and gobbled up the 
whole string. As <CODE>\d*</CODE> can match on an empty string the complete 
regular expression matched successfully. 
<P><PRE>    Beginning is &lt;I have 2 numbers: 53147&gt;, number is &lt;&gt;.
</PRE>
<P>Here are some variants, most of which don't work: 
<P><PRE>    $_ = "I have 2 numbers: 53147";
    @pats = qw{
        (.*)(\d*)
        (.*)(\d+)
        (.*?)(\d*)
        (.*?)(\d+)
        (.*)(\d+)$
        (.*?)(\d+)$
        (.*)\b(\d+)$
        (.*\D)(\d+)$
    };
</PRE>
<P><PRE>    for $pat (@pats) {
        printf "%-12s ", $pat;
        if ( /$pat/ ) {
            print "&lt;$1&gt; &lt;$2&gt;\n";
        } else {
            print "FAIL\n";
        }
    }
</PRE>
<P>That will print out: 
<P><PRE>    (.*)(\d*)    &lt;I have 2 numbers: 53147&gt; &lt;&gt;
    (.*)(\d+)    &lt;I have 2 numbers: 5314&gt; &lt;7&gt;
    (.*?)(\d*)   &lt;&gt; &lt;&gt;
    (.*?)(\d+)   &lt;I have &gt; &lt;2&gt;
    (.*)(\d+)$   &lt;I have 2 numbers: 5314&gt; &lt;7&gt;
    (.*?)(\d+)$  &lt;I have 2 numbers: &gt; &lt;53147&gt;
    (.*)\b(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;
    (.*\D)(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;
</PRE>
<P>As you see, this can be a bit tricky. It's important to realize that a 
regular expression is merely a set of assertions that gives a definition of 
success. There may be 0, 1, or several different ways that the definition might 
succeed against a particular string. And if there are multiple ways it might 
succeed, you need to understand backtracking to know which variety of success 
you will achieve. 
<P>When using lookahead assertions and negations, this can all get even tricker. 
Imagine you'd like to find a sequence of non-digits not followed by ``123''. You 
might try to write that as 
<P><PRE>    $_ = "ABC123";
    if ( /^\D*(?!123)/ ) {              # Wrong!
        print "Yup, no 123 in $_\n";
    }
</PRE>
<P>But that isn't going to match; at least, not the way you're hoping. It claims 
that there is no 123 in the string. Here's a clearer picture of why it that 
pattern matches, contrary to popular expectations: 
<P><PRE>    $x = 'ABC123' ;
    $y = 'ABC445' ;
</PRE>
<P><PRE>    print "1: got $1\n" if $x =~ /^(ABC)(?!123)/ ;
    print "2: got $1\n" if $y =~ /^(ABC)(?!123)/ ;
</PRE>
<P><PRE>    print "3: got $1\n" if $x =~ /^(\D*)(?!123)/ ;
    print "4: got $1\n" if $y =~ /^(\D*)(?!123)/ ;
</PRE>
<P>This prints 
<P><PRE>    2: got ABC
    3: got AB
    4: got ABC
</PRE>
<P>You might have expected test 3 to fail because it seems to a more general 
purpose version of test 1. The important difference between them is that test 3 
contains a quantifier (<CODE>\D*</CODE>) and so can use backtracking, whereas 
test 1 will not. What's happening is that you've asked ``Is it true that at the 
start of $x, following 0 or more non-digits, you have something that's not 
123?'' If the pattern matcher had let <CODE>\D*</CODE> expand to <FONT 
size=-1>``ABC'',</FONT> this would have caused the whole pattern to fail. The 
search engine will initially match <CODE>\D*</CODE> with <FONT 
size=-1>``ABC''.</FONT> Then it will try to match <CODE>(?!123</CODE> with 
``123'', which of course fails. But because a quantifier (<CODE>\D*</CODE>) has 
been used in the regular expression, the search engine can backtrack and retry 
the match differently in the hope of matching the complete regular expression. 
<P>The pattern really, <EM>really</EM> wants to succeed, so it uses the standard 
pattern back-off-and-retry and lets <CODE>\D*</CODE> expand to just <FONT 
size=-1>``AB''</FONT> this time. Now there's indeed something following <FONT 
size=-1>``AB''</FONT> that is not ``123''. It's in fact <FONT 
size=-1>``C123'',</FONT> which suffices. 
<P>We can deal with this by using both an assertion and a negation. We'll say 
that the first part in <CODE>$1</CODE> must be followed by a digit, and in fact, 
it must also be followed by something that's not ``123''. Remember that the 
lookaheads are zero-width expressions--they only look, but don't consume any of 
the string in their match. So rewriting this way produces what you'd expect; 
that is, case 5 will fail, but case 6 succeeds: 
<P><PRE>    print "5: got $1\n" if $x =~ /^(\D*)(?=\d)(?!123)/ ;
    print "6: got $1\n" if $y =~ /^(\D*)(?=\d)(?!123)/ ;
</PRE>
<P><PRE>    6: got ABC
</PRE>
<P>In other words, the two zero-width assertions next to each other work as 
though they're ANDed together, just as you'd use any builtin assertions: 
<CODE>/^$/</CODE> matches only if you're at the beginning of the line <FONT 
size=-1>AND</FONT> the end of the line simultaneously. The deeper underlying 
truth is that juxtaposition in regular expressions always means <FONT 
size=-1>AND,</FONT> except when you write an explicit <FONT size=-1>OR</FONT> 
using the vertical bar. <CODE>/ab/</CODE> means match ``a'' <FONT 
size=-1>AND</FONT> (then) match ``b'', although the attempted matches are made 
at different positions because ``a'' is not a zero-width assertion, but a 
one-width assertion. 
<P>One warning: particularly complicated regular expressions can take 
exponential time to solve due to the immense number of possible ways they can 
use backtracking to try match. For example this will take a very long time to 
run 
<P><PRE>    /((a{0,5}){0,5}){0,5}/
</PRE>
<P>And if you used <CODE>*</CODE>'s instead of limiting it to 0 through 5 
matches, then it would take literally forever--or until you ran out of stack 
space. 
<P><FONT size=-1>A</FONT> powerful tool for optimizing such beasts is 
``independent'' groups, which do not backtrace (see 
<EM><CODE>(?&gt;pattern)</CODE></EM>). Note also that zero-length 
lookahead/lookbehind assertions will not backtrace to make the tail match, since 
they are in ``logical'' context: only the fact whether they match or not is 
considered relevant. For an example where side-effects of a lookahead 
<EM>might</EM> have influenced the following match, see 
<EM><CODE>(?&gt;pattern)</CODE></EM>. 
<P>
<HR>

<H2><A name=Version_8_Regular_Expressions>Version 8 Regular Expressions</A></H2>
<P>In case you're not familiar with the ``regular'' Version 8 regex routines, 
here are the pattern-matching rules not described above. 
<P>Any single character matches itself, unless it is a <EM>metacharacter</EM> 
with a special meaning described here or above. You can cause characters that 
normally function as metacharacters to be interpreted literally by prefixing 
them with a ``\'' (e.g., ``\.'' matches a ``.'', not any character; ``\\'' 
matches a ``\''). <FONT size=-1>A</FONT> series of characters matches that 
series of characters in the target string, so the pattern <CODE>blurfl</CODE> 
would match ``blurfl'' in the target string. 
<P>You can specify a character class, by enclosing a list of characters in 
<CODE>[]</CODE>, which will match any one character from the list. If the first 
character after the ``['' is ``^'', the class matches any character not in the 
list. Within a list, the ``-'' character is used to specify a range, so that 
<CODE>a-z</CODE> represents all characters between ``a'' and ``z'', inclusive. 
If you want ``-'' itself to be a member of a class, put it at the start or end 
of the list, or escape it with a backslash. (The following all specify the same 
class of three characters: <CODE>[-az]</CODE>, <CODE>[az-]</CODE>, and 
<CODE>[a\-z]</CODE>. All are different from <CODE>[a-z]</CODE>, which specifies 
a class containing twenty-six characters.) 
<P>Characters may be specified using a metacharacter syntax much like that used 
in <FONT size=-1>C:</FONT> ``\n'' matches a newline, ``\t'' a tab, ``\r'' a 
carriage return, ``\f'' a form feed, etc. More generally, \ <EM>nnn</EM>, where 
<EM>nnn</EM> is a string of octal digits, matches the character whose <FONT 
size=-1>ASCII</FONT> value is <EM>nnn</EM>. Similarly, \x<EM>nn</EM>, where 
<EM>nn</EM> are hexadecimal digits, matches the character whose <FONT 
size=-1>ASCII</FONT> value is <EM>nn</EM>. The expression \c<EM>x</EM> matches 
the <FONT size=-1>ASCII</FONT> character control-<EM>x</EM>. Finally, the ``.'' 
metacharacter matches any character except ``\n'' (unless you use <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#item_s">/s</A>). 
<P>You can specify a series of alternatives for a pattern using ``|'' to 
separate them, so that <CODE>fee|fie|foe</CODE> will match any of ``fee'', 
``fie'', or ``foe'' in the target string (as would <CODE>f(e|i|o)e</CODE>). The 
first alternative includes everything from the last pattern delimiter (``('', 
``['', or the beginning of the pattern) up to the first ``|'', and the last 
alternative contains everything from the last ``|'' to the next pattern 
delimiter. For this reason, it's common practice to include alternatives in 
parentheses, to minimize confusion about where they start and end. 
<P>Alternatives are tried from left to right, so the first alternative found for 
which the entire expression matches, is the one that is chosen. This means that 
alternatives are not necessarily greedy. For example: when mathing 
<CODE>foo|foot</CODE> against ``barefoot'', only the ``foo'' part will match, as 
that is the first alternative tried, and it successfully matches the target 
string. (This might not seem important, but it is important when you are 
capturing matched text using parentheses.) 
<P>Also remember that ``|'' is interpreted as a literal within square brackets, 
so if you write <CODE>[fee|fie|foe]</CODE> you're really only matching 
<CODE>[feio|]</CODE>. 
<P>Within a pattern, you may designate subpatterns for later reference by 
enclosing them in parentheses, and you may refer back to the <EM>n</EM>th 
subpattern later in the pattern using the metacharacter \<EM>n</EM>. Subpatterns 
are numbered based on the left to right order of their opening parenthesis. 
<FONT size=-1>A</FONT> backreference matches whatever actually matched the 
subpattern in the string being examined, not the rules for that subpattern. 
Therefore, <CODE>(0|0x)\d*\s\1\d*</CODE> will match ``0x1234 0x4321'', but not 
``0x1234 01234'', because subpattern 1 actually matched ``0x'', even though the 
rule <CODE>0|0x</CODE> could potentially match the leading 0 in the second 
number. 
<P>
<HR>

<H2><A name=WARNING_on_1_vs_1>WARNING on \1 vs $1</A></H2>
<P>Some people get too used to writing things like: 
<P><PRE>    $pattern =~ s/(\W)/\\\1/g;
</PRE>
<P>This is grandfathered for the <FONT size=-1>RHS</FONT> of a substitute to 
avoid shocking the <STRONG>sed</STRONG> addicts, but it's a dirty habit to get 
into. That's because in PerlThink, the righthand side of a <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#item_s">s///</A> is a 
double-quoted string. <CODE>\1</CODE> in the usual double-quoted string means a 
control-A. The customary Unix meaning of <CODE>\1</CODE> is kludged in for <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#item_s">s///</A>. 
However, if you get into the habit of doing that, you get yourself into trouble 
if you then add an <CODE>/e</CODE> modifier. 
<P><PRE>    s/(\d+)/ \1 + 1 /eg;        # causes warning under -w
</PRE>
<P>Or if you try to do 
<P><PRE>    s/(\d+)/\1000/;
</PRE>
<P>You can't disambiguate that by saying <CODE>\{1}000</CODE>, whereas you can 
fix it with <CODE>${1}000</CODE>. Basically, the operation of interpolation 
should not be confused with the operation of matching a backreference. Certainly 
they mean two different things on the <EM>left</EM> side of the <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#item_s">s///</A>. 
<P>
<HR>

<H2><A name=Repeated_patterns_matching_zero_>Repeated patterns matching 
zero-length substring</A></H2>
<P><FONT size=-1>WARNING:</FONT> Difficult material (and prose) ahead. This 
section needs a rewrite. 
<P>Regular expressions provide a terse and powerful programming language. As 
with most other power tools, power comes together with the ability to wreak 
havoc. 
<P><FONT size=-1>A</FONT> common abuse of this power stems from the ability to 
make infinite loops using regular expressions, with something as innocous as: 
<P><PRE>    'foo' =~ m{ ( o? )* }x;
</PRE>
<P>The <CODE>o?</CODE> can match at the beginning of <CODE>'foo'</CODE>, and 
since the position in the string is not moved by the match, <CODE>o?</CODE> 
would match again and again due to the <CODE>*</CODE> modifier. Another common 
way to create a similar cycle is with the looping modifier <CODE>//g</CODE>: 
<P><PRE>    @matches = ( 'foo' =~ m{ o? }xg );
</PRE>
<P>or 
<P><PRE>    print "match: &lt;$&amp;&gt;\n" while 'foo' =~ m{ o? }xg;
</PRE>
<P>or the loop implied by <CODE>split().</CODE> 
<P>However, long experience has shown that many programming tasks may be 
significantly simplified by using repeated subexpressions which may match 
zero-length substrings, with a simple example being: 
<P><PRE>    @chars = split //, $string;           # // is not magic in split
    ($whitewashed = $string) =~ s/()/ /g; # parens avoid magic s// /
</PRE>
<P>Thus Perl allows the <CODE>/()/</CODE> construct, which <EM>forcefully breaks 
the infinite loop</EM>. The rules for this are different for lower-level loops 
given by the greedy modifiers <CODE>*+{}</CODE>, and for higher-level ones like 
the <CODE>/g</CODE> modifier or <CODE>split()</CODE> operator. 
<P>The lower-level loops are <EM>interrupted</EM> when it is detected that a 
repeated expression did match a zero-length substring, thus 
<P><PRE>   m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;
</PRE>
<P>is made equivalent to 
<P><PRE>   m{   (?: NON_ZERO_LENGTH )* 
      | 
        (?: ZERO_LENGTH )? 
    }x;
</PRE>
<P>The higher level-loops preserve an additional state between iterations: 
whether the last match was zero-length. To break the loop, the following match 
after a zero-length match is prohibited to have a length of zero. This 
prohibition interacts with backtracking (see <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlre.html#Backtracking">Backtracking</A>), 
and so the <EM>second best</EM> match is chosen if the <EM>best</EM> match is of 
zero length. 
<P>Say, 
<P><PRE>    $_ = 'bar';
    s/\w??/&lt;$&amp;&gt;/g;
</PRE>
<P>results in 
<CODE>"&lt;</CODE>&lt;b&gt;&lt;&gt;&lt;a&gt;&lt;&gt;&lt;r&gt;&lt;&gt;``&gt;. At 
each position of the string the best match given by non-greedy <CODE>??</CODE> 
is the zero-length match, and the <EM>second best</EM> match is what is matched 
by <CODE>\w</CODE>. Thus zero-length matches alternate with one-character-long 
matches. 
<P>Similarly, for repeated <CODE>m/()/g</CODE> the second-best match is the 
match at the position one notch further in the string. 
<P>The additional state of being <EM>matched with zero-length</EM> is associated 
to the matched string, and is reset by each assignment to <CODE>pos().</CODE> 
<P>
<HR>

<H2><A name=Creating_custom_RE_engines>Creating custom RE engines</A></H2>
<P>Overloaded constants (see <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/lib/overload.html">the overload 
manpage</A>) provide a simple way to extend the functionality of the <FONT 
size=-1>RE</FONT> engine. 
<P>Suppose that we want to enable a new <FONT size=-1>RE</FONT> escape-sequence 
<CODE>\Y|</CODE> which matches at boundary between white-space characters and 
non-whitespace characters. Note that 
<CODE>(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)</CODE> matches exactly at these 
positions, so we want to have each <CODE>\Y|</CODE> in the place of the more 
complicated version. We can create a module <CODE>customre</CODE> to do this: 
<P><PRE>    package customre;
    use overload;
</PRE>
<P><PRE>    sub import {
      shift;
      die "No argument to customre::import allowed" if @_;
      overload::constant 'qr' =&gt; \&amp;convert;
    }
</PRE>
<P><PRE>    sub invalid { die "/$_[0]/: invalid escape '\\$_[1]'"}
</PRE>
<P><PRE>    my %rules = ( '\\' =&gt; '\\', 
                  'Y|' =&gt; qr/(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)/ );
    sub convert {
      my $re = shift;
      $re =~ s{ 
                \\ ( \\ | Y . )
              }
              { $rules{$1} or invalid($re,$1) }sgex; 
      return $re;
    }
</PRE>
<P>Now <CODE>use customre</CODE> enables the new escape in constant regular 
expressions, i.e., those without any runtime variable interpolations. As 
documented in <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/lib/overload.html">the overload 
manpage</A>, this conversion will work only over literal parts of regular 
expressions. For <CODE>\Y|$re\Y|</CODE> the variable part of this regular 
expression needs to be converted explicitly (but only if the special meaning of 
<CODE>\Y|</CODE> should be enabled inside $re): 
<P><PRE>    use customre;
    $re = &lt;&gt;;
    chomp $re;
    $re = customre::convert $re;
    /\Y|$re\Y|/;
</PRE>
<P>
<HR>

<H2><A name=SEE_ALSO>SEE ALSO</A></H2>
<P><A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#Regexp_Quote_Like_Operators">Regexp 
Quote-Like Operators</A>. 
<P><A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlop.html#Gory_details_of_parsing_quoted_c">Gory 
details of parsing quoted constructs</A>. 
<P><A href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlfunc/pos.html">pos</A>. 

<P><A href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perllocale.html">the 
perllocale manpage</A>. 
<P><EM>Mastering Regular Expressions</EM> (see <A 
href="file:///F:/BOOKS/PERL/PerlDoc/manual/pod/perlbook.html">the perlbook 
manpage</A>) by Jeffrey Friedl. 
<HR>

<H1>DISCLAIMER</H1>We are painfully aware that these documents may contain 
incorrect links and misformatted HTML. Such bugs lie in the automatic 
translation process that automatically created the hundreds and hundreds of 
separate documents that you find here. Please <B>do not report</B> link or 
formatting bugs, because we cannot fix per-document problems. The only bug 
reports that will help us are those that supply working patches to the 
<I>installhtml</I> or <I>pod2html</I> programs, or to the <TT>Pod::HTML</TT> 
module itself, for which I and the entire Perl community will shower you with 
thanks and praises. 
<P>If rather than formatting bugs, you encounter substantive content errors in 
these documents, such as mistakes in the explanations or code, please use the 
<I>perlbug</I> utility included with the Perl distribution. 
<P>
<DL>
  <DD>--Tom Christiansen, Perl Documentation Compiler and Editor</DD></DL>
<P>
<HR>
Return to the <A href="file:///F:/BOOKS/PERL/PerlDoc/manual/index.html">Perl 
Documentation Index</A>. <BR>Return to the <A href="http://www.perl.com/">Perl 
Home Page</A>. </BODY></HTML>
