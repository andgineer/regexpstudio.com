<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="author" content="Andrey V. Sorokin, St-Petersburg, Copyright 2000 - anso@mail.ru">
<meta name="GENERATOR" content="FAR 1.63">
<meta name="description" content="Примеры использования регулярных
выражений (regular expressions) в Delphi">
<meta name="keywords" content="delphi pascal regular expressions
регулярные выражения freeware component Andrey Sorokin">
<title>Текст с высоты птичьего полета или Регулярные выражения</title>
</head>

<body>

<h2 align="center">Текст с высоты птичьего полета или Регулярные выражения</h2>
<p align="right">
 <i>
   &quot;Look for a white shirt and a white apron,&quot; said the head which had<br>
   been put together, speaking in a rather faint voice.  &quot;I'm the cook.&quot;
 </i>
   <br>
   L. Frank Baum, The Emerald City of Oz


<p>
При решении прикладных задач, полезно рассматривать их с 
высоты &quot;птичьего полета&quot;. Многие знают что это
может существенно ускорить разработку, но не многие этим 
пользуются.

<p>
Разница в посимвольной обработке строк и обработке с помощью 
регулярных выражений в том, что в первом случае Вы думаете 
прежде всего как достичь цели, а во втором - а какая цель 
Вам собственно нужна ? %-) Кроме того, посимвольные алгоритмы
трудно модифицировать, не говоря уж о том, что любая модификация
сопровождается перекомпиляцией приложения.

<p>
В этой небольшой статье собрано несколько иллюстраций
использования регулярных выражений в Delphi.

<a name="regexpr_content">
<UL>
 <LI><a href="#regexpr_ai">Детектор лжи</a>
 <LI><a href="#regexpr_webbots">Персонального www-робота - каждому !</a>
 <LI><a href="#regexpr_decorator">Господин Оформитель</a>
 <LI><a href="#regexpr_panacea">Панацея ?</a>
</UL>

<p>
<font size="-1">
 <i>
  <DL>
   <DT>Прим.
    <DD>
     <UL>
       <LI>Если для Вас приведенные примеры выражений
выглядят как древнеегипетские письмена, то ознакомьтесь
с описанием их синтаксиса в любой книге о Perl или на 
<a href="http://anso.virtualave.net/regexpr.htm#tregexpr_syntax_rus">
http://anso.virtualave.net/regexpr.htm</a>.
Они гораздо проще чем кажутся !
       <LI>Для компиляции этих примеров достаточно добавить
<a href="#regexpr_url">regexpr.pas</a> в список файлов проекта и вписать 
'uses regexpr;' в юниты, где Вы используете регулярные выражения.
     </UL>
  </DL>
 </i>
</font>

<p>&nbsp;
<a name="regexpr_ai"><h4>Детектор лжи</h4>

<p>
Предположим, Вам необходимо выманить ;) у пользователя адрес 
его электронной почты (моральную сторону и маркетинговую 
обоснованность подобной затеи мы здесь рассматривать не будем).

<p>
Идея в том, что если отвергать синтаксически некорректные 
адреса, то большинству пользователей надоест играть в эту 
орлянку и они либо откажутся от Вашей программы / уйдут с 
web-страницы, либо введут синтаксически корректный адрес. 
А как рядовому юзеру проще всего ввести такой адрес ?..
Правильно ! Проще всего ввести свой реальный e-mail !

<p>
Естественно, что вариант с 
<PRE>
 p := Pos ('@', email);
 if (p > 1) and (p < length (email))
  then ...
</PRE>
проблемы не решает. Желательно как минимум просмотреть
строку на предмет отсутствия некорретных символов а также
наличия домена второго (или выше) уровня. Конечно, любой
программист напишет такой анализатор... строк этак на *дцать
и с перспективой перекомпилировать программу если что-то не 
впишется в эту проверку. 
<p>
А теперь забудьте о посимвольной обработке и посмотрите на 
этот же анализатор, упрятанный в одну строку :

<p>
<PRE>
if ExecRegExpr ('[\w\d\-\.]+@[\w\d\-]+(\.[\w\d\-]+)+', email) 
 then ... gotcha! ...
</PRE>

<p>
Регулярные выражения позволяют гибко реализовать достаточно
изощренные проверки. Вот, скажем абсолютно корректная проверка
на ... римские цифры любой величины (шаблон позаимствован
из книги &quot;Mastering Perl&quot;):
<PRE>
 const
  Mask1 = '^(?i)M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$';
  ...
  if not ExecRegExpr (Mask1, DBEdit1.Text) then begin
    ... show error message ...
    DBEdit1.SetFocus;
   end;
</PRE>


<p align="right"><font size="-1">
<a href="#regexpr_content">Оглавление</a></font>

<p>&nbsp;
<a name="regexpr_webbots"><h4>Персонального www-робота - каждому !</h4>
<p>
В последнее время появилось неимоверное число программок,
вылущивающих информацию из web-страниц. Так вот, на мой взгляд
это гораздо разумнее делать с помощью регулярных выражений.
Не изобретайте велосипед, используйте метро ! 8-)

<p>
Например вот таким нехитрым способом можно получить курс 
доллара и дату этого курса программно, не рассматривая 
рекламные баннеры (да простят меня CityCat и ФинМаркет ;) ).
<p>
Бросьте на форму TBitBtn, TLabel и TNMHTTP (TNMHTTP здесь 
использован исключительно для упрощения примера. Использовать 
эту гадость в реальной жизни не советую :-E~ ) и вставьте такой
код обработки нажатия BitBtn1:

<PRE>
procedure TForm1.BitBtn1Click(Sender: TObject);
 const
  Template = '(?i)Официальный курс ЦБ по доллару'
   + '.*Дата\s*Курс\s*Курс пок.\s*Курс прод. [^&lt;\d]*'
   + '(\d?\d)/(\d?\d)/(\d\d)\s*[\d.]+\s*([\d.]+)';
 begin
  NMHTTP1.Get ('http://win.www.citycat.ru/finance/finmarket/_CBR/');
  with TRegExpr.Create do try
     Expression := Template;
     if Exec (NMHTTP1.Body) then begin
       Label1.Caption := Format ('Курс на %s.%s.%s: %s',
         [Match [2], Match [1], Match [3], Match [4]]);
      end;
    finally Free;
   end;
 end;
</PRE>
<p>
В этом примере используется очень мощный механизм backtrack,
отличающий NFA (non-deterministic finite state machine) 
реализацию регулярных выражений от DFA (deterministic 
finite state machine). В случае с NFA (на базе которого
построен и TRegExpr) мы получаем возможность работать с 
подвыражениями, что и использовано в примере выше для 
выделения из шаблона элементов даты и собственно курса.
<p>
Кстати, здесь уже проявляются и ограничения регулярных
выражений (см. <a href="#regexpr_panacea">Панацея ?</a>).
Решая подбную задачу, я бы предварительно обработал текст: 
убрал бы незначимые тэги (ИМХО для надержного анализа 
достаточно оставить только табличные тэги), из оставшихся 
тэгов убрал бы все модификаторы (size, align и т.п.), 
убрал бы все переводы строк, а табуляции заменил на 
пробелы и убрал после этого повторяющиеся пробелы. 
После этого можно уже написать гораздо более надежное 
регулярное выражение.

<p>
А вот так можно достаточно надежно вынуть из неформализованного
текста все Санкт-Петербургские номера телефонов (представленные
как '(812)123-4567' или '+7 (812) 12-345-67' и т.д., причем
извлечены будут внутригородские части номеров):

<PRE>
procedure ExtractPhones (const AText : string; APhones : TStrings);
 begin
  with TRegExpr.Create do try
     Expression := '(\+\d *)?(\((\d+)\) *)?(\d+(-\d*)*)'; 
     if Exec (AText) then
      REPEAT
        if Match [3] = '812'
         then APhones.Add (Match [4])
      UNTIL not ExecNext;
    finally Free;
   end;
 end;
</PRE>

<p align="right"><font size="-1">
<a href="#regexpr_content">Оглавление</a></font>

<p>&nbsp;
<a name="regexpr_decorator"><h4>Господин Оформитель</h4>

<p>
Необходимо некий текст отобразить в html-странице, но 
предварительно желательно выделить гиперссылками все 
встречающиеся в нем URL.<br>
Вот пример реализации (он не всегда сработает, но ведь 
100% распознавание даже теоретически невозможно,
да и в такого рода задачах не страшно если что-то
не будет найдено. Страшно впустую тратить время
на вспомогательные по сути вещи):
<PRE>
 function DecorateURLs (const AText : string) : string;
 const
  URLTemplate =
   '(?i)(FTP|HTTP)://(' // Protocol
   + '[\w\d\-]+(\.[\w\d\-]+)+' // TCP addr / domain name
   + ')((/[ \w\d\-\\\.]+)+)*' // unix path
   + '(\?[^ =&]+=[^ =&]+(&[^ =&]+=[^ =&]+)*)?'; // request params
 var
  PrevPos : integer;
 begin
  Result := '';
  PrevPos := 1;
  with TRegExpr.Create do try
     Expression := URLTemplate; 
     if Exec (AText) then
      REPEAT
        Result := Result + System.Copy (AText, PrevPos,
         MatchPos [0] - PrevPos) +
         '&lt;a href=&quot;' + Match [0] + '&quot;&gt;' + Match [0] + '&lt;/a&gt;';
        PrevPos := MatchPos [0] + MatchLen [0];
      UNTIL not ExecNext;
     Result := Result + System.Copy (AText, PrevPos, MaxInt); // Tail
    finally Free;
   end;
 end;
</PRE>

<p>
Обратите внимание, что в приведенном выше примере Вы имеете
возможность легко выделять из URL протокол, домен, путь
и параметры запроса. Скажем, вы можете, прятать
из видимой пользователю гиперссылки какие-то части URL.
Например, вот так Вы покажете только доменные имена
(при этом сами гиперссылки останутся полными):
<PRE>
        Result := Result + System.Copy (AText, PrevPos, 
         MatchPos [0] - PrevPos) +
         '&lt;a href=&quot;' + Match [0] + '&quot;&gt;' + Match [2] + '&lt;/a&gt;';
</PRE>

<p align="right"><font size="-1">
<a href="#regexpr_content">Оглавление</a></font>

<p>&nbsp;
<a name="regexpr_panacea"><h4>Панацея ?</h4>
<p>
Возможно, в этом месте уже не лишним будет умерить 
пыл энтузиастов, в особенности тех, кому случалось 
использовать Перл.

<p>
Дело в том, что Перл - интерпретирующий язык. Основное
следствие из этого - чем меньше операторов выполняется,
тем быстрее (как правило) работает программа. В большистве 
случаев регулярное выражение отработает быстрее чем самый 
элементарный посимвольный анализ строки.

<p>
Поэтому, не кажется диким реализация функции Trim
как выражения '^\s*(\S*)\s*$'. 

<p>
Думаю, не надо объяснять насколько это глупо в истинно 
компилируемом Паскале. Так что, если анализируемая строка 
имеет простую структуру - напишите элементарный и очень
быстрый цикл по ее разбору и не связывайтесь с регулярными 
выражениями.

<p>
Кроме того, не рекомендую использовать регулярные выражения
там, где нужен полноценный парсер. Если, например, Вам
нужно разобрать на теги HTML - поищите для этого более
подходящий инструмент !

<p>
Если же искомая или проверяемая строка имеет сложную
структуру, если эта структура может меняться, тогда
это наш клиент ;) Если же описание должно меняться
без перекомпиляции программы, то серьезной альтернативы 
регулярным выражениям практически нет.

<p align="right"><font size="-1">
<a href="#regexpr_content">Оглавление</a></font>


<p>
Успехов !

<a name="regexpr_url"><p>
Да, чуть не забыл, библиотека которая устраняет досадную
забывчивость разработчиков Delphi и позволяет использовать
в Delphi регулярные выражения без необходимости таскать
за собой какие-либо DLL, лежит на<br>
<a href="http://anso.virtualave.net/delphi_stuff_rus.htm">
http://anso.virtualave.net/delphi_stuff_rus.htm</a><br>
или<br>
<a href="http://www.delphicity.net/component.cfm?
componentid=239">
http://www.delphicity.net/component.cfm?componentid=239</a>.
<p>

<p align="right">
<i>Андрей Сорокин</i><br>
<a href="mailto:anso@mail.ru">anso@mail.ru</a>

</body>
</html>
