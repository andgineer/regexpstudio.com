<html><head><meta name="generator" content="Help & Manual 2.6.3"><title>TRegExpr interface</title></head>
<body background="niceblue.gif" bgcolor="#FFFFFF">
<small><table width="100%"><tr><td align="right"><a href="tregexpr_syntax.htm"><img src="1arrow4.gif" border="0"></a><a href="tregexpr_testrexp.htm"><img src="1arrow5.gif" border="0"></a></td></tr></small><table width="100%" border="0" cellspacing="0" cellpadding="3" bgcolor="#C6E7FF"><tr><td align="left">
<font face="Arial" size="4" color="#000000"><font face="Arial" size="4" color="#0000FF"><b>TRegExpr interface</b></font><font face="Arial" size="5" color="#000000"><font face="Arial" size="5" color="#0000FF"><b>
<br>
</b></font></font></font>

</td></tr></table><br>

<font face="Arial" size="3" color="#000000"><font face="Arial" size="3" color="#0000FF"><b>Public methods and properties of TRegExpr</b></font><font face="Arial" size="3" color="#000000">:
<br>

<br>
<b><a name="tregexpr_version">class function VersionMajor</b> : integer;
<br>
<b>class function VersionMinor</b> : integer;
<br>
Return major and minor version, for example, for v. 0.944 VersionMajor = 0 and VersionMinor = 944
<br>

<br>
<b>property Expression</b> : string
<br>
Regular expression.
<br>
For optimization, TRegExpr will automatically compiles it into 'P-code' (You can see it with help of Dump method) and stores in internal structures. Real [re]compilation occures only when it really needed - while calling Exec[Next], Substitute, Dump, etc and only if Expression or other P-code affected properties was changed after last [re]compilation.
<br>
If any errors while [re]compilation occures, Error method is called (by default Error raises exception - see below)
<br>

<br>
<b>property Modifier</b><b>Str</b> : string
<br>
Set/get default values of <a href="tregexpr_syntax.htm#about_modifiers">r.e.modifiers</a>. Format of the string is similar as in <a href="tregexpr_syntax.htm#inline_modifiers">(?ismx-ismx)</a>. For example ModifierStr := 'i-x' will switch on modifier /i, switch off /x and leave unchanged others.
<br>
If you try to set unsupported modifier, Error will be called (by defaul Error raises exception ERegExpr).
<br>

<br>
<b><a name="tregexpr_modifier_i">property ModifierI</b> : boolean
<br>
<a href="tregexpr_syntax.htm#modifier_i">Modifier /i</a> - ("caseinsensitive"), initialized with <a href="tregexpr_interface.htm#modifier_defs">RegExprModifierI</a> value.
<br>

<br>
<b><a name="tregexpr_modifier_r">property ModifierR</b> : boolean
<br>
<a href="tregexpr_syntax.htm#modifier_r">Modifier /r</a> - ("Russian.syntax extensions), initialized with <a href="tregexpr_interface.htm#modifier_defs">RegExprModifierR</a> value.
<br>

<br>
<b><a name="tregexpr_modifier_s">property ModifierS</b> : boolean
<br>
<a href="tregexpr_syntax.htm#modifier_s">Modifier /s</a> - '.' works as any char (else doesn't match <a href="tregexpr_interface.htm#lineseparators">LineSeparators</a> and <a href="tregexpr_interface.htm#linepairedseparator">LinePairedSeparator</a>), initialized with <a href="tregexpr_interface.htm#modifier_defs">RegExprModifierS</a> value.
<br>

<br>
<b><a name="tregexpr_modifier_g">property ModifierG</b> : boolean;
<br>
<a href="tregexpr_syntax.htm#modifier_g">Modifier /g</a> Switching off modifier /g switchs all operators in non-greedy style, so if ModifierG = False, then all '*' works as '*?', all '+' as '+?' and so on, initialized with <a href="tregexpr_interface.htm#modifier_defs">RegExprModifierG</a> value.
<br>

<br>
<b><a name="tregexpr_modifier_m">property ModifierM</b> : boolean;
<br>
<a href="tregexpr_syntax.htm#modifier_m">Modifier /m</a> Treat string as multiple lines. That is, change `^' and `$' from matching at only the very start or end of the string to the start or end of any line anywhere within the string, initialized with <a href="tregexpr_interface.htm#modifier_defs">RegExprModifierM</a> value.
<br>

<br>
<b><a name="tregexpr_modifier_x">property ModifierX</b> : boolean;
<br>
<a href="tregexpr_syntax.htm#modifier_x">Modifier /x</a> - ("eXtended syntax"), initialized with <a href="tregexpr_interface.htm#modifier_defs">RegExprModifierX</a> value.
<br>

<br>
<b>function Exec</b> (const AInputString : string) : boolean;
<br>
match a programm against a string AInputString
<br>
!!! Exec store AInputString into InputString property
<br>

<br>
<b>function ExecNext</b> : boolean;
<br>
 find next match:
<br>
    Exec (AString); ExecNext;
<br>
 works same as
<br>
    Exec (AString);
<br>
    if MatchLen [0] = 0 then ExecPos (MatchPos [0] + 1) 
<br>
     else ExecPos (MatchPos [0] + MatchLen [0]);
<br>
 but it's more simpler !
<br>

<br>
<b>function ExecPos</b> (AOffset: integer = 1) : boolean;
<br>
find match for InputString starting from AOffset position
<br>
(AOffset=1 - first char of InputString)
<br>

<br>
<b>property InputString</b> : string;
<br>
returns current input string (from last Exec call or last assign to this property).
<br>
Any assignment to this property clear Match* properties !
<br>

<br>
<b><a name="tregexpr_substitute">function Substitute</b> (const ATemplate : string) : string;
<br>
Returns ATemplate with '$&amp;' or '$0' replaced by whole r.e. occurence and '$n' replaced by occurence of subexpression #n.
<br>
Since v.0.929 '$' used instead of '\' (for future extensions and for more Perl-compatibility) and accept more then one digit.
<br>
If you want place into template raw '$' or '\', use prefix '\'
<br>
Example: '1\$ is $2\\rub\\' -&gt; '1$ is &lt;Match[2]&gt;\rub\'
<br>
If you want to place raw digit after '$n' you must delimit n with curly braces '{}'.
<br>
Example: 'a$12bc' -&gt; 'a&lt;Match[12]&gt;bc', 'a${1}2bc' -&gt; 'a&lt;Match[1]&gt;2bc'.
<br>

<br>
<b>procedure Split</b> (AInputStr : string; APieces : TStrings);
<br>
Split AInputStr into APieces by r.e. occurencies
<br>
Internally calls Exec[Next]
<br>

<br>
<a name="tregexpr_replace">function Replace (AInputStr : RegExprString;
<br>
  const AReplaceStr : RegExprString;
<br>
  AUseSubstitution : boolean = False) : RegExprString;
<br>
 Returns AInputStr with r.e. occurencies replaced by AReplaceStr
<br>
 If AUseSubstitution is true, then AReplaceStr will be used
<br>
 as template for Substitution methods.
<br>
 For example:
<br>
  Expression := '({-i}block|var)\s*\(\s*([^ ]*)\s*\)\s*';
<br>
  Replace ('BLOCK( test1)', 'def "$1" value "$2"', True);
<br>
   will return:  def 'BLOCK' value 'test1'
<br>
  Replace ('BLOCK( test1)', 'def "$1" value "$2"', False)
<br>
   will return:  def "$1" value "$2"
<br>
 Internally calls Exec[Next]
<br>

<br>
<b><a name="subexprmatchcount">property SubExprMatchCount</b> : integer; // ReadOnly
<br>
Number of subexpressions has been found in last Exec* call.
<br>
If there are no subexpr. but whole expr was found (Exec* returned True), then SubExprMatchCount=0, if no subexpressions nor whole r.e. found (Exec* returned false) then SubExprMatchCount=-1.
<br>
Note, that some subexpr. may be not found and for such subexpr. MathPos=MatchLen=-1 and Match=''.
<br>
For example: Expression := '(1)?2(3)?';
<br>
 Exec ('123'): SubExprMatchCount=2, Match[0]='123', [1]='1', [2]='3'
<br>
 Exec ('12'): SubExprMatchCount=1, Match[0]='12', [1]='1'
<br>
 Exec ('23'): SubExprMatchCount=2, Match[0]='23', [1]='', [2]='3'
<br>
 Exec ('2'): SubExprMatchCount=0, Match[0]='2'
<br>
 Exec ('7') - return False: SubExprMatchCount=-1
<br>

<br>
<b>property MatchPos</b> [Idx : integer] : integer; // ReadOnly
<br>
pos of entrance subexpr. #Idx into tested in last Exec* string. First subexpr. have Idx=1, last - MatchCount, whole r.e. have Idx=0.
<br>
Returns -1 if in r.e. no such subexpr. or this subexpr. not found in input string.
<br>

<br>
<b>property MatchLen</b> [Idx : integer] : integer; // ReadOnly
<br>
len of entrance subexpr. #Idx r.e. into tested in last Exec* string. First subexpr. have Idx=1, last - MatchCount, whole r.e. have Idx=0.
<br>
Returns -1 if in r.e. no such subexpr. or this subexpr. not found in input string.
<br>

<br>
<b><a name="tregexpr_match">property Match</b> [Idx : integer] : string; // ReadOnly
<br>
== copy (InputString, MatchPos [Idx], MatchLen [Idx])
<br>
Returns '' if in r.e. no such subexpr. or this subexpr. not found in input string.
<br>

<br>
<b>function LastError</b> : integer;
<br>
Returns ID of last error, 0 if no errors (unusable if Error method raises exception) and clear internal status into 0 (no errors).
<br>

<br>
<b>function ErrorMsg</b> (AErrorID : integer) : string; virtual;
<br>
Returns Error message for error with ID = AErrorID.
<br>

<br>
<b>property CompilerErrorPos</b> : integer; // ReadOnly
<br>
Returns pos in r.e. there compiler stopped.
<br>
Usefull for error diagnostics
<br>

<br>
<b>property <a name="tregexpr_spacechars">SpaceChars</b> : RegExprString
<br>
Contains chars, treated as \s (initially filled with RegExprSpaceChars global constant)
<br>

<br>
<b>property <a name="tregexpr_wordchars">WordChars</b> : RegExprString;
<br>
Contains chars, treated as \w (initially filled with RegExprWordChars global constant)
<br>

<br>
<b>property <a name="lineseparators">LineSeparators</b> : RegExprString
<br>
line separators (like \n in Unix), initially filled with RegExprLineSeparators global constant)
<br>
see also <a href="tregexpr_syntax.htm#syntax_line_separators">about line separators</a>
<br>

<br>
<b>property <a name="linepairedseparator">LinePairedSeparator</b> : RegExprString
<br>
paired line separator (like \r\n in DOS and Windows).
<br>
must contain exactly two chars or no chars at all, initially filled with RegExprLinePairedSeparator global constant)
<br>
see also <a href="tregexpr_syntax.htm#syntax_line_separators">about line separators</a>
<br>

<br>
For example, if You need Unix-style behaviour, assign LineSeparators := #$a (newline character) and LinePairedSeparator := '' (empty string), if You want to accept as line separators only \x0D\x0A but not \x0D or \x0A alone, then assign LineSeparators := '' (empty string) and LinePairedSeparator := #$d#$a.
<br>

<br>
By default 'mixed' mode is used (defined in RegExprLine[Paired]Separator[s] global constants): LineSeparators := #$d#$a; LinePairedSeparator := #$d#$a. Behaviour of this mode is detailed described in the <a href="tregexpr_syntax.htm#syntax_line_separators">syntax section</a>.
<br>

<br>
<b>class function InvertCaseFunction</b>  (const Ch : REChar) : REChar;
<br>
Converts Ch into upper case if it in lower case or in lower if it in upper (uses current system local setings)
<br>

<br>
<b><a name="invertcase">property InvertCase</b> : TRegExprInvertCaseFunction;
<br>
Set this property if you want to override case-insensitive functionality.
<br>
Create set it to RegExprInvertCaseFunction (InvertCaseFunction by default)
<br>

<br>
<b>procedure Compile</b>;
<br>
[Re]compile r.e. Usefull for example for GUI r.e. editors (to check all properties validity).
<br>

<br>
<b>function Dump</b> : string;
<br>
dump a compiled regexp in vaguely comprehensible form
<br>

<br>

<br>
<font face="Arial" size="3" color="#0000FF"><b>Global constants
<br>
</b></font></font><font face="Arial" size="3" color="#000000">
<br>
<a name="modifier_defs">Modifiers default values:
<br>
  <b>RegExprModifierI</b><font face="Arial" size="3" color="#7F0000"><b> </b></font></font><font face="Arial" size="3" color="#000000">: boolean = False;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_i">TRegExpr.ModifierI</a>
<br>
  <b>RegExprModifierR</b> : boolean = True;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_r">TRegExpr.ModifierR</a>
<br>
  <b>RegExprModifierS</b> : boolean = True;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_s">TRegExpr.ModifierS</a>
<br>
  <b>RegExprModifierG</b> : boolean = True;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_g">TRegExpr.ModifierG</a>
<br>
  <b>RegExprModifierM</b> : boolean = False;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_m">TRegExpr.ModifierM</a>
<br>
  <b>RegExprModifierX</b> : boolean = False;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_x">TRegExpr.ModifierX</a>
<br>

<br>
  <b>RegExprSpaceChars</b> : RegExprString = ' '#$9#$A#$D#$C;
<br>
  // default for SpaceChars property
<br>

<br>
  <b>RegExprWordChars</b> : RegExprString =
<br>
    '0123456789'
<br>
  + 'abcdefghijklmnopqrstuvwxyz'
<br>
  + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_';
<br>
  // default value for WordChars property
<br>

<br>
  <b>RegExprLineSeparators</b> : RegExprString =
<br>
   #$d#$a{$IFDEF UniCode}#$b#$c#$2028#$2029#$85{$ENDIF};
<br>
  // default value for LineSeparators property
<br>
  <b>RegExprLinePairedSeparator</b> : RegExprString =
<br>
   #$d#$a;
<br>
  // default value for LinePairedSeparator property
<br>

<br>
  <b>RegExpr</b><b>Invert</b><b>CaseFunction</b> : TRegExprInvertCaseFunction = TRegExpr.InvertCaseFunction; 
<br>
  // default for InvertCase property
<br>

<br>

<br>
<font face="Arial" size="3" color="#0000FF"><b>Usefull global functions</b></font></font><font face="Arial" size="3" color="#000000">
<br>

<br>
<b>function ExecRegExpr</b> (const ARegExpr, AInputStr : string) : boolean;
<br>
true if string AInputString match regular expression ARegExpr
<br>
! will raise exeption if syntax errors in ARegExpr
<br>

<br>
<b>procedure SplitRegExpr</b> (const ARegExpr, AInputStr : string; APieces : TStrings);
<br>
Split AInputStr into APieces by r.e. ARegExpr occurencies
<br>

<br>
<b>function ReplaceRegExpr</b> (const ARegExpr, AInputStr, AReplaceStr : string;
<br>
 AUseSubstitution : boolean = False) : string;
<br>
Returns AInputStr with r.e. occurencies replaced by AReplaceStr.
<br>
If AUseSubstitution is true, then AReplaceStr will be used as template for Substitution methods.
<br>
For example:
<br>
 ReplaceRegExpr ('({-i}block|var)\s*\(\s*([^ ]*)\s*\)\s*',
<br>
  'BLOCK( test1)', 'def "$1" value "$2"', True)
<br>
 will return:  def 'BLOCK' value 'test1'
<br>
 ReplaceRegExpr ('({-i}block|var)\s*\(\s*([^ ]*)\s*\)\s*',
<br>
  'BLOCK( test1)', 'def "$1" value "$2"')
<br>
  will return:  def "$1" value "$2"
<br>

<br>
<b>function Quot</b><b>e</b><b>RegExprMetaChars</b> (const AStr : string) : string;
<br>
Replace all metachars with its safe representation, for example 'abc$cd.(' converts into 'abc\$cd\.\('
<br>
This function usefull for r.e. autogeneration from user input
<br>

<br>
<b>function RegExprSubExpressions</b> (const ARegExpr : string;
<br>
 ASubExprs : TStrings; AExtendedSyntax : boolean = False) : integer;
<br>
Makes list of subexpressions found in ARegExpr r.e.
<br>
In ASubExps every item represent subexpression, from first to last, in format:
<br>
  String - subexpression text (without '()')
<br>
  low word of Object - starting position in ARegExpr, including '(' if exists! (first position is 1)
<br>
  high word of Object - length, including starting '(' and ending ')' if exist!
<br>
AExtendedSyntax - must be True if modifier /x will be On while using the r.e.
<br>
Usefull for GUI editors of r.e. etc (You can find example of using in <a href="tregexpr_testrexp.htm">TestRExp.dpr</a> project)
<br>

<br>
<b>Result code</b>&nbsp;&nbsp;&nbsp;<b>Meaning</b>
<br>
</font><font face="Arial" size="2" color="#000000"><hr></font><font face="Arial" size="3" color="#000000">
<br>
<b>0</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Success. No unbalanced brackets was found;
<br>
<b>-1</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;there are not enough closing brackets ')';
<br>
<b>-(n+1)</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at position <b>n</b> was found opening '[' without corresponding closing ']';
<br>
<b>n</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at position <b>n</b> was found closing bracket ')' without corresponding opening '('.
<br>

<br>
If Result &lt;&gt; 0, then ASubExprs can contain empty items or illegal ones
<br>

<br>

<br>
<font face="Arial" size="3" color="#0000FF"><b>Exception type</b></font></font><font face="Arial" size="3" color="#000000">
<br>

<br>
Default error handler of TRegExpr raise exception:
<br>

<br>
<b>ERegExpr </b>= class (Exception)
<br>
   public
<br>
    ErrorCode : integer; // error code. Compilation error codes are before 1000.
<br>
    CompilerErrorPos : integer; // Position in r.e. where compilation error occured
<br>
  end;
<br>

<br>

<br>
<font face="Arial" size="3" color="#0000FF"><b><a name="unicode_support">How to use Unicode</b></font></font><font face="Arial" size="3" color="#000000">
<br>

<br>
TRegExpr now supports UniCode, but it works <b>very slow</b> :(
<br>
Who want to optimize it ? ;)
<br>
Use it only if you really need Unicode support !
<br>
Remove '.' in {.$DEFINE UniCode} in regexpr.pas. After that all strings will be treated as WideString.
<br>

<br>
</font></font>

<small><table width="100%"><tr><td align="right"><a href="tregexpr_syntax.htm"><img src="1arrow4.gif" border="0"></a><a href="tregexpr_testrexp.htm"><img src="1arrow5.gif" border="0"></a></td></tr></small>

<script>     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){                 (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),             m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)     })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');      ga('create', 'UA-90368520-1', 'auto');     ga('send', 'pageview');  </script>

</body></html>
