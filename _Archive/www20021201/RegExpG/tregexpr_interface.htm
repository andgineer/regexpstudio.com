<html><head><meta name="generator" content="Help & Manual 2.6.3"><title>TRegExpr interface</title></head>
<body background="niceblue.gif" bgcolor="#FFFFFF">
<small><table width="100%"><tr><td align="right"><a href="tregexpr_syntax.htm"><img src="1arrow4.gif" border="0"></a><a href="tregexpr_testrexp.htm"><img src="1arrow5.gif" border="0"></a></td></tr></small><table width="100%" border="0" cellspacing="0" cellpadding="3" bgcolor="#C6E7FF"><tr><td align="left">
<font face="Arial" size="4" color="#000000"><font face="Arial" size="4" color="#0000FF"><b>TRegExpr Interface</b></font><font face="Arial" size="5" color="#000000"><font face="Arial" size="5" color="#0000FF"><b>
<br>
</b></font></font></font>

</td></tr></table><br>

<font face="Arial" size="3" color="#000000"><font face="Arial" size="3" color="#0000FF"><b>Public Methoden und Eigenschaften von TRegExpr:</b></font><font face="Arial" size="3" color="#000000">
<br>

<br>
<a name="tregexpr_version">class function VersionMajor: integer;
<br>
<b>class function VersionMinor</b>: integer;
<br>
Sie geben die grosse und kleine Versionsummer zur�ck, Beispiel 0.944 ergibt: VersionMajor = 0 und VersionMinor = 944
<br>

<br>
<b>property Expression</b> : string
<br>
Regul�rer Ausdruck
<br>
Aus Optimierungsgr�nden �bersetzt TRegExpr den regul�ren Ausdruck in den P-Code, den Du kannst ihn sehen mittels der Methode Dump. Der P-Code wird in den internen Strukturen gespeichert.
<br>
Eine [Neu]�bersetzung findet nur statt, wenn sie wirklich ben�tigt wird, beim Aufruf von Exec, ExecNext, Substitute, Dump etc. und auch dann nur, wenn der regul�re Ausdruck oder eine ihn betreffende Eigenschaft ge�ndert wurde seit der letzten [Neu]�bersetzung.
<br>
Falls ein �bersetzungsfehler auftaucht, wird die Methode Error aufgerufen. Diese erzeugt standardm�ssig eine Ausnahme vom Typ ERegExpr - siehe unten
<br>

<br>
<b>property ModifierStr</b> : string
<br>
Setze / hole die Standardwerte f�r die <a href="tregexpr_syntax.htm#about_modifiers">Modifikatoren</a>. Modifikatoren in Regul�ren Ausdr�cken <a href="tregexpr_syntax.htm#inline_modifiers">(?ismx-ismx)</a> ersetzen diese Standardwerte. Falls Du nicht unterst�tzte Modifikatoren setzst, wird die Methode Error aufgerufen, die standardm�ssig eine Ausnahme vom Typ EregExpr erzeugt.
<br>

<br>
<b><a name="tregexpr_modifier_i">property ModifierI</b> : boolean
<br>
<a href="tregexpr_syntax.htm#modifier_i">Modifikator /i</a> - Gross- oder Kleinschreibweise wird nicht ber�cksichtigt. Standardm�ssig False
<br>

<br>
<b><a name="tregexpr_modifier_r">property ModifierR</b> : boolean
<br>
<a href="tregexpr_syntax.htm#modifier_r">Modiifikator /r</a> - benutze die f�r Russen erweiterte Syntax. Standardm�ssig True. (war die Eigenschaft ExtSyntaxEnabled in fr�heren Versionen)
<br>

<br>
<b><a name="tregexpr_modifier_s">property ModifierS</b> : boolean
<br>
<a href="tregexpr_syntax.htm#modifier_s">Modifikator /s</a> - '.' findet jedes beliebige Zeichen (sonst wie [^\n]). Standardm�ssig True.
<br>

<br>
<b><a name="tregexpr_modifier_g">property ModifierG</b> : boolean
<br>
<a href="tregexpr_syntax.htm#modifier_g">Modifikator /g</a> - schaltet alle Operatoren in den gen�gsamen Modus. Falls ModifierG False ist, dann arbeitet '*' als '*?', und '+' als '+?' und so weiter. Standardm�ssig True.
<br>

<br>
<b><a name="tregexpr_modifier_m">property ModifierM</b> : boolean
<br>
<a href="tregexpr_syntax.htm#modifier_m">Modifikator /m</a> - Behandelt den Zielstring als mehrzeiligen String. So finden "^" und "$" nicht mehr nur den Anfang und das Ende des Zielstringes, sondern auch Zeilenseparatoren innerhalb des Zielstrings. Standardm�ssig False.
<br>

<br>
<b><a name="tregexpr_modifier_x">property ModifierX</b> : boolean
<br>
<a href="tregexpr_syntax.htm#modifier_x">Modifikator /x</a> - Erweiterte Syntax, erlaubt das Formatieren des regul�renm Ausdruckes zur besseren Lesbarkeit. Standardm�ssig False.
<br>

<br>
<b>function Exec</b> (const AInputString : string) : boolean;
<br>
L�sst einen Regul�ren Ausdruck auf einem Zielstring ablaufen. Exec speichert AInputString in der Eigenschaft InputString
<br>

<br>
<b>function ExecNext</b> : boolean;
<br>
Findet n�chsten Treffer:
<br>
    Exec (AString); ExecNext;
<br>
 Arbeitet gleich wie
<br>
    Exec (AString);
<br>
    if MatchLen [0] = 0 then ExecPos (MatchPos [0] + 1) 
<br>
     else ExecPos (MatchPos [0] + MatchLen [0]);
<br>
 ist aber viel einfacher!
<br>

<br>
<b>function ExecPos</b> (AOffset: integer = 1) : boolean;
<br>
Findet einen Treffer im Zielstring, jedoch beginnend ab Position Aoffset. (Hinweis: AOffset=1 - das erste Zeichen im Zielstring)
<br>

<br>
<b>property InputString</b> : string;
<br>
Gibt den aktuellen Zielstring zur�ck (vom letzten Exec-Aufruf oder der letzten Zuweisung an diese Eigenschaft. Eine Zuweisung an diese Eigenschaft l�scht die Match*-Eigenschaften!
<br>

<br>
<b><a name="tregexpr_substitute">function Substitute</b> (const ATemplate : string) : string;
<br>
Gibt ATemplate mit durch $&amp; oder $0 ersetztem Regul�ren Ausdruck und durch die Vorkommen von Regul�ren Unterausdr�cken ersetzten $n zur�ck. Seit Version v.0.929 wird das '$' anstelle des '\' verwendet (aus Gr�nden der k�nfitgen Erweiterbarkeit und der besseren Kompatibilit�t zu Perl) und es akzeptiert mehr als eine Ziffer. Falls Du die Zeichen $ oder \ als Literale in einem Template verwenden m�chtest, nutze das vorangestellte Escape-Zeichen: Beispiel:
<br>
    '1\$ is $2\\rub\\' -&gt; '1$ is &lt;Match[2]&gt;\rub\'
<br>
Falls Du eine Ziffer als Literal hinter einem $n plazieren m�chtest, dann musst Du das n mit geschweiften Klammern {} begrenzen: Beispiel:
<br>
    'a$12bc' -&gt; 'a&lt;Match[12]&gt;bc'
<br>
    'a${1}2bc' -&gt; 'a&lt;Match[1]&gt;2bc'.
<br>

<br>
<b>procedure Split</b> (AInputStr : string; APieces : TStrings);
<br>
Zerlege AInputStr in die Einzelteile APieces mit den Treffern des Regul�ren Ausdruckes als Trenner
<br>

<br>
<a name="tregexpr_replace">function Replace (AInputStr : RegExprString;
<br>
  const AReplaceStr : RegExprString;
<br>
  AUseSubstitution : boolean = False) : RegExprString;
<br>
 Gibt AInputStr mit den Treffern des regul�ren Ausdruckes ersetzt durch AReplaceStr. Wenn AUseSubstitution true ist, wird AReplaceStr genutzt als Vorlage f�r die Ersetzungsmethoden.
<br>
 Beispiel:
<br>
&nbsp; Expression := '({-i}block|var)\s*\(\s*([^ ]*)\s*\)\s*';
<br>
&nbsp; Replace ('BLOCK( test1)', 'def "$1" value "$2"', True);
<br>
&nbsp;&nbsp; gibt zur�ck:&nbsp; def 'BLOCK' value 'test1'
<br>
&nbsp; Replace ('BLOCK( test1)', 'def "$1" value "$2"', False)
<br>
&nbsp;&nbsp; gibt zur�ck:&nbsp; def "$1" value "$2"
<br>
 Ruft intern Exec[Next] auf.
<br>

<br>

<br>
<b><a name="subexprmatchcount">property SubExprMatchCount</b> : integer; // ReadOnly
<br>
Die Anzahl der Unterausdr�cke, die beim letzten Exec-Aufruf gefunden wurde. Falls keine Unterausdr�cke gefunden wurden, aber der gesamte Regul�re Ausdruck schon (Exec gab True zur�ck), ist dieser Wert 0. Falls weder Unterausdr�cke noch der gesamte Regul�re Ausdruck gefunden wurde (Exec gab False zur�ck), dann ist dieser Wert -1. Beachte, dass einige Unterausdr�cke eventuell nicht gefunden werden k�nnen und f�r solche Unterausdr�cke gilt:
<br>
MathPos=MatchLen=-1 and Match=''.
<br>
Beispiel: Ausdruck := '(1)?2(3)?';
<br>
Exec ('123'): SubExprMatchCount=2, Match[0]='123', [1]='1', [2]='3'
<br>
Exec ('12'): SubExprMatchCount=1, Match[0]='23', [1]='1'
<br>
Exec ('23'): SubExprMatchCount=2, Match[0]='23', [1]='', [2]='3'
<br>
Exec ('2'): SubExprMatchCount=0, Match[0]='2'
<br>
Exec ('7') - ergibt False: SubExprMatchCount=-1
<br>

<br>
<b>property MatchPos</b> [Idx : integer] : integer; // ReadOnly
<br>
Position des Starts des Unterausdruckes mit der Nummer Idx, gefunden beim letzten Exec-Aufruf. Der erste Unterausdruck hat Idx=1, der Letzte - MatchCount. Der gesamte Regul�re Ausdruck hat Idx=0. Gibt -1 zur�ck, wenn entweder der gew�nschte Unterausdruck im Regul�ren Ausdruck nicht vorhanden ist oder im Zielstring nicht gefunden wurde.
<br>

<br>
<b>property MatchLen</b> [Idx : integer] : integer; // ReadOnly
<br>
(* Die L�nge des Unterausdruckes mit der Nummer Idx. Numerierung und R�ckgabewert wie bei MatchPos. *)
<br>

<br>
    <a name="tregexpr_match">property Match [Idx : integer] : string; // ReadOnly
<br>
== copy (InputString, MatchPos [Idx], MatchLen [Idx])
<br>
Gibt einen Leerstring zur�ck, wenn entweder der gew�nschte Unterausdruck im Regul�ren Ausdruck nicht vorhanden ist oder im Zielstring nicht gefunden wurde
<br>

<br>
<b>function LastError</b> : integer;
<br>
Gibt die ID des letzten Fehler zur�ck, 0 f�r keinen Fehler. Nicht zu verwenden, wenn die Error Methode eine Ausnahme erzeugt. Setzt den internen Fehlerzustand zur�ck auf 0.
<br>

<br>
<b>function ErrorMsg</b> (AErrorID : integer) : string; virtual;
<br>
Gibt die Fehlermeldung zur Fehler-ID AErrorID zur�ck.
<br>

<br>
<b>property CompilerErrorPos</b> : integer; // ReadOnly
<br>
Gibt die Position im Regul�ren Ausdruck zur�ck, wo der Compiler beim �bersetzen stoppte. N�tzlich bei der Fehlerdiagnose.
<br>

<br>
<b>property <a name="tregexpr_spacechars">SpaceChars</b> : RegExprString
<br>
Beinhaltet die Zeichen, die f�r das Metazeichen \s verwendet werden. Anf�nglich gef�llt mit der globalen Konstanten RegExprSpaceChars.
<br>

<br>
<b>property <a name="tregexpr_wordchars">WordChars</b> : RegExprString
<br>
Beinhaltet die Zeichen, die f�r das Metazeichen \w verwendet werden. Anf�nglich gef�llt mit der globalen Konstanten RegExprWordChars.
<br>

<br>
<b>property <a name="lineseparators">LineSeparators</b> : RegExprString
<br>
Beinhaltet die Zeichen, die f�r Zeilenseparatoren wie \n in UNIX verwendet werden. Anf�nglich gef�llt mit der globalen Konstanten RegExprLineSeparators. Beachte auch <a href="tregexpr_syntax.htm#syntax_line_separators">Zeilenseparatoren</a>
<br>

<br>
<b>property <a name="linepairedseparator">LinePairedSeparators</b> : RegExprString
<br>
Beinhaltet die Zeichen, die paarweise f�r Zeilenseparatoren wie \r\n in DOS/Windows verwendet werden. Es m�ssen genau zwei oder gar keine Zeichen sein. Anf�nglich gef�llt mit der globalen Konstanten RegExprLinePairedSeparators. Beachte auch <a href="tregexpr_syntax.htm#syntax_line_separators">Zeilenseparatoren</a>
<br>

<br>
Beispiel: Wenn Du den UNIX-Stil als Zeilenseparatoren haben m�chtest, dann weise LineSeparators := #$a (Newline Zeichen) und LinePairedSeparator := '' (Leerstring) zu. Wenn Du als Zeilenseparatoren nur genau \x0D\x0A akzeptieren m�chtest, jedoch nicht \x0D oder \x0A aleine, dann weise LineSeparators := '' (Leerstring) und LinePairedSeparator := #$d#$a zu.
<br>

<br>
Standardm�ssig ist der gemsichte Modus aktiv wie er definiert ist in den globalen Konstanten RegExprLine[Paired]Separator[s]: LineSeparators := #$d#$a; LinePairedSeparator := #$d#$a. Das Verhalten dieses Modus wird ausf�hrlich im Abschnitt <a href="tregexpr_syntax.htm#syntax_line_separators">Syntax besprochen</a>.
<br>

<br>
<b>class function InvertCaseFunction</b>  (const Ch : REChar) : REChar;
<br>
Wandelt Ch in Grossschreibweise um, wenn er in Kleinschreibweise vorliegt oder umgekehrt. Die aktuellen lokalen System-Einstellungen werden daf�r benutzt.
<br>

<br>
<b><a name="invertcase">property InvertCase</b> : TRegExprInvertCaseFunction;
<br>
Setze diese Eigenschaft, wenn Du die <a href="tregexpr_syntax.htm#modifier_i">Umwandlungsfunktion</a> zwischen der Gross- oder Kleinschreibung durch eine eigene ersetzen m�chtest. Standardm�ssig auf InvertCaseFunction gesetzt.
<br>

<br>
<b>procedure Compile</b>;
<br>
�bersetzt den regul�ren Ausdruck [erneut]. N�tzlich f�r das interaktive Erstellen eines regul�ren Ausdruckes in einem Editor, zur Pr�fung der G�ltigkeit aller Parameter, etc.
<br>

<br>
<b>function Dump</b> : string;
<br>
Gibt den �bersetzten Regul�ren Ausdruck in knapp verst�ndlicher Form zur�ck.
<br>

<br>

<br>
<font face="Arial" size="3" color="#0000FF"><b>Globale Konstanten
<br>
</b></font></font><font face="Arial" size="3" color="#000000">
<br>
<a name="modifier_defs">Standardm�ssig f�r Modifikatoren
<br>
  <b>RegExprModifierI</b><font face="Arial" size="3" color="#7F0000"><b> </b></font></font><font face="Arial" size="3" color="#000000">: boolean = False;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_i">TRegExpr.ModifierI</a>
<br>
  <b>RegExprModifierR</b> : boolean = True;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_r">TRegExpr.ModifierR</a>
<br>
  <b>RegExprModifierS</b> : boolean = True;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_s">TRegExpr.ModifierS</a>
<br>
  <b>RegExprModifierG</b> : boolean = True;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_g">TRegExpr.ModifierG</a>
<br>
  <b>RegExprModifierM</b> : boolean = False;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_m">TRegExpr.ModifierM</a>
<br>
  <b>RegExprModifierX</b> : boolean = False;&nbsp;&nbsp;&nbsp;// <a href="tregexpr_interface.htm#tregexpr_modifier_x">TRegExpr.ModifierX</a>
<br>

<br>
  <b>RegExprSpaceChars</b> : RegExprString = ' '#$9#$A#$D#$C;
<br>
  // Standardbelegung f�r die Eigenschaft SpaceChars
<br>

<br>
  <b>RegExprWordChars</b> : RegExprString = 
<br>
     '0123456789'
<br>
  + 'abcdefghijklmnopqrstuvwxyz'
<br>
  + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_';
<br>
  // Standardbelegung f�r die Eigenschaft WordChars
<br>

<br>
  <b>RegExprLineSeparators</b> : RegExprString = 
<br>
  #$D#$A{$IFDEF UniCode}#$B#$C#$2028#$2029#$85{$ENDIF};
<br>
  // Standardbelegung f�r die Eigenschaft LineSeparators
<br>

<br>
  <b>RegExprLinePairedSeparators</b> : RegExprString = ' '#$D#$A;
<br>
  // Standardbelegung f�r die Eigenschaft LinePairedSeparators
<br>

<br>
  <b>RegExprInvertCaseFunction</b> : TRegExprInvertCaseFunction = TRegExpr.InvertCaseFunction; 
<br>
  // Standardbelegung f�r die Eigenschaft InvertCase
<br>

<br>
<b>function RegExprSubExpressions</b> (const ARegExpr : string;
<br>
 ASubExprs : TStrings; AExtendedSyntax : boolean = False) : integer;
<br>
 Erzeugt eine Liste der Teilausdr�cke in einem regul�ren Ausdruck.
<br>
 In ASubExps repr�sentiert jeder String einen Teilausdruck, beginnend mit dem ersten bis zum letzten, im Format:
<br>
  String - Teilausdruck-Text (ohne die Klammern '()')
<br>
  Low Word (TString.Object) - Startposition im ARegExpr, inklusive '(' falls einer existiert (die erste Position ist 1)
<br>
  High Word (TString.Object) - L�nge, inklusive Start-'(' und End-')' falls einer existiert.
<br>
 AExtendedSyntax - must be True if modifier /x will be On while
<br>
 using the r.e.
<br>
 N�tzlich f�r GUIs f�r Editoren f�r regul�re Ausdr�cke etc. (Du findest ein Beispiel davon im Projekt)
<br>

<br>
<b>Result code</b>&nbsp;&nbsp;&nbsp;<b>Meaning</b>
<br>
</font><font face="Arial" size="2" color="#000000"><hr></font><font face="Arial" size="3" color="#000000">
<br>
<b>0</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Success. No unbalanced brackets was found;
<br>
<b>-1</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;there are not enough closing brackets ')';
<br>
<b>-(n+1)</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at position <b>n</b> was found opening '[' without corresponding closing ']';
<br>
<b>n</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at position <b>n</b> was found closing bracket ')' without corresponding opening '('.
<br>

<br>
// Falls Result &lt;&gt; 0, dann k�nnten in ASubExprs auch leere Items enthalten sein.
<br>

<br>

<br>

<br>
<font face="Arial" size="3" color="#0000FF"><b>N�tzliche globale Functionen</b></font></font><font face="Arial" size="3" color="#000000">
<br>

<br>
<b>function ExecRegExpr</b> (const ARegExpr, AInputStr : string) : boolean;
<br>
True, wenn in AInputString der Regul�re Ausdruck AregExpr gefunden wird. Erzeugt eine Ausnahme, wenn es Syntaxfehler hat in AregExpr
<br>

<br>
<b>procedure SplitRegExpr</b> (const ARegExpr, AInputStr : string; APieces : TStrings);
<br>
Zerlegt AInputStr in die Einzelteile APieces getrennt durch die Treffer des Regul�ren Ausdruckes ARegExpr.
<br>

<br>
<b>function ReplaceRegExpr</b> (const ARegExpr, AInputStr, AReplaceStr : string) : string;
<br>
Gibt AInputStr mit den Treffern des regul�ren Audruckes ersetzt durch AReplaceStr. Wenn AUseSubstitution true ist, wird AReplaceStr genutzt als Vorlage f�r die Ersetzungsmethoden.
<br>
Beispiel:
<br>
 ReplaceRegExpr ('({-i}block|var)\s*\(\s*([^ ]*)\s*\)\s*',
<br>
&nbsp; 'BLOCK( test1)', 'def "$1" value "$2"', True)
<br>
 gibt zur�ck:&nbsp; def 'BLOCK' value 'test1'
<br>
 ReplaceRegExpr ('({-i}block|var)\s*\(\s*([^ ]*)\s*\)\s*',
<br>
&nbsp; 'BLOCK( test1)', 'def "$1" value "$2"')
<br>
&nbsp; gibt zur�ck:&nbsp; def "$1" value "$2"
<br>
 ReplaceRegExpr ('({-i}block|var)\s*\(\s*([^ ]*)\s*\)\s*',
<br>
&nbsp; 'BLOCK( test1)', 'def "$1" value "$2"', True)
<br>
 gibt zur�ck:&nbsp; def 'BLOCK' value 'test1'
<br>
 ReplaceRegExpr ('({-i}block|var)\s*\(\s*([^ ]*)\s*\)\s*',
<br>
&nbsp; 'BLOCK( test1)', 'def "$1" value "$2"')
<br>
&nbsp; gibt zur�ck:&nbsp; def "$1" value "$2"
<br>

<br>

<br>
<b>function QuoteRegExprMetaChars</b> (const AStr : string) : string;
<br>
Ersetze alle Metazeichen durch deren sichere Repr�sentationen. Beispiel:
<br>
  'abc$cd.(' wird gewandelt in 'abc\$cd\.\('
<br>
Diese Funktion ist n�tzlich, wenn ein Benutzer einen Regul�ren Ausdruck selbst zusammenstellen darf, ohne sich um das Escaping k�mmern zu m�ssen.
<br>

<br>
<font face="Arial" size="3" color="#0000FF"><b>Ausnahme Typ</b></font></font><font face="Arial" size="3" color="#000000">
<br>

<br>
Die standardm�ssige Fehlerbehandlungsroutine erzeugt folgende Ausnahme:
<br>

<br>
 ERegExpr = class (Exception)
<br>
   public
<br>
    ErrorCode : integer; // Error-Code. �bersetzungsfehler haben Codes &lt; 1000.
<br>
    CompilerErrorPos : integer; // Position im Regul�ren Ausdruck, wo der �bersetzungsfehler auftauchte
<br>
  end;
<br>

<br>
<font face="Arial" size="3" color="#0000FF"><b><a name="unicode_support">Wie wird Unicode benutzt?</b></font></font><font face="Arial" size="3" color="#000000">
<br>

<br>
TRegExpr unterst�tzt nun UniCode, aber leider sehr langsam :(
<br>
Wer m�chte dies optimieren? ;)
<br>
Ben�tze es nur, wenn Du wirklich nicht auf Unicode-Unterst�tzung verzichten kannst!
<br>
Entferne '.' aus {.$DEFINE UniCode} in regexpr.pas. Danach werden alle Strings als Delphis WideString (= Unicode) behandelt
<br>

<br>
</font></font>

<small><table width="100%"><tr><td align="right"><a href="tregexpr_syntax.htm"><img src="1arrow4.gif" border="0"></a><a href="tregexpr_testrexp.htm"><img src="1arrow5.gif" border="0"></a></td></tr></small>

<script>     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){                 (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),             m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)     })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');      ga('create', 'UA-90368520-1', 'auto');     ga('send', 'pageview');  </script>

</body></html>
